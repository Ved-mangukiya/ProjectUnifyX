<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üßÆ PlotMaster - Advanced Area Calculator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #f3f4f6;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .app-container {
            display: flex;
            min-height: 100vh;
        }

        .sidebar {
            width: 250px;
            background: #1f2937;
            color: white;
            padding: 20px;
            position: fixed;
            height: 100%;
            transition: transform 0.3s ease;
        }

        .sidebar.hidden {
            transform: translateX(-250px);
        }

        .sidebar-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 30px;
        }

        .sidebar-header h1 {
            font-size: 1.5rem;
            font-weight: 700;
        }

        .nav-item {
            padding: 12px 15px;
            margin: 5px 0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .nav-item:hover {
            background: #374151;
        }

        .nav-item.active {
            background: #3b82f6;
        }

        .main-content {
            flex: 1;
            margin-left: 250px;
            padding: 20px;
            transition: margin-left 0.3s ease;
        }

        .main-content.full {
            margin-left: 0;
        }

        .page {
            display: none;
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .page.active {
            display: block;
        }

        .header {
            background: linear-gradient(135deg, #3b82f6 0%, #60a5fa 100%);
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .toggle-sidebar {
            background: #ffffff;
            color: #3b82f6;
            border: none;
            padding: 8px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
        }

        .section {
            margin-bottom: 20px;
            padding: 15px;
            background: #f9fafb;
            border-radius: 8px;
        }

        .section-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 15px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            font-weight: 500;
            color: #374151;
            margin-bottom: 6px;
        }

        input, select {
            width: 100%;
            padding: 10px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 0.95rem;
            background: #ffffff;
            transition: border-color 0.3s ease;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .sides-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
        }

        .side-group {
            background: #f3f4f6;
            padding: 10px;
            border-radius: 6px;
        }

        .btn {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn:hover {
            background: #2563eb;
            transform: translateY(-1px);
        }

        #canvas {
            border: 1px solid #d1d5db;
            border-radius: 8px;
            background: #ffffff;
            width: 100%;
            max-width: 600px;
            height: 400px;
            margin: 0 auto;
            cursor: crosshair;
        }

        .canvas-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .results {
            background: #e5e7eb;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
        }

        .history-item {
            background: #f3f4f6;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 10px;
            cursor: pointer;
        }

        .history-item:hover {
            background: #e5e7eb;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-content {
            background: white;
            padding: 20px;
            border-radius: 12px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .close-btn {
            background: #ef4444;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 6px;
            cursor: pointer;
            float: right;
        }

        .error {
            background: #fee2e2;
            color: #dc2626;
            padding: 10px;
            border-radius: 6px;
            margin-top: 10px;
        }

        @media (max-width: 768px) {
            .sidebar {
                transform: translateX(-250px);
            }
            .main-content {
                margin-left: 0;
            }
            .main-content.full {
                margin-left: 0;
            }
            .sidebar.active {
                transform: translateX(0);
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <span>üßÆ</span>
                <h1>PlotMaster</h1>
            </div>
            <div class="nav-item" data-page="home">üè† Home</div>
            <div class="nav-item" data-page="editor">üìê Plot Editor</div>
            <div class="nav-item" data-page="results">üìä Results</div>
            <div class="nav-item" data-page="history">üìú History</div>
        </div>

        <div class="main-content" id="mainContent">
            <div class="header">
                <h1 id="pageTitle">Welcome to PlotMaster</h1>
                <button class="toggle-sidebar" onclick="toggleSidebar()">‚ò∞ Menu</button>
            </div>

            <div class="page active" id="home">
                <div class="section">
                    <h2 class="section-title">Welcome to PlotMaster</h2>
                    <p>Calculate and visualize land plot areas with ease. Features include:</p>
                    <ul>
                        <li>Calculate areas for 3-8 sided polygons</li>
                        <li>Divide plots into equal or custom areas</li>
                        <li>Interactive canvas with zoom and pan</li>
                        <li>Save and load plot configurations</li>
                        <li>Export results as PNG or PDF</li>
                        <li>View calculation history</li>
                    </ul>
                    <button class="btn" onclick="navigateTo('editor')">Start Plotting</button>
                </div>
            </div>

            <div class="page" id="editor">
                <div class="section">
                    <h2 class="section-title">Plot Configuration</h2>
                    <div class="form-group">
                        <label for="numSides">Number of Sides (3-8)</label>
                        <input type="number" id="numSides" min="3" max="8" value="4">
                    </div>
                    <div class="form-group">
                        <label for="unit">Unit</label>
                        <select id="unit">
                            <option value="meters">Meters</option>
                            <option value="feet">Feet</option>
                            <option value="yards">Yards</option>
                            <option value="inches">Inches</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <button class="btn" onclick="generateSideInputs()">Generate Sides</button>
                        <button class="btn" onclick="importConfig()">Import Config</button>
                        <input type="file" id="importFile" style="display: none;" accept=".json">
                    </div>
                    <div id="sideInputs" class="sides-grid"></div>
                    <div id="errorMessage"></div>
                    <div class="form-group">
                        <button class="btn" onclick="calculateAndDraw()">Calculate & Draw</button>
                        <button class="btn" onclick="saveConfig()">Save Config</button>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-title">Visual Plot</h2>
                    <div class="canvas-controls">
                        <button class="btn" onclick="clearCanvas()">Clear</button>
                        <button class="btn" onclick="rotatePlot()">Rotate</button>
                        <button class="btn" onclick="zoomIn()">Zoom In</button>
                        <button class="btn" onclick="zoomOut()">Zoom Out</button>
                        <button class="btn" onclick="downloadCanvas()">Download PNG</button>
                        <button class="btn" onclick="downloadResultsAsPDF()">Download PDF</button>
                    </div>
                    <canvas id="canvas"></canvas>
                </div>

                <div class="section" id="divisionSection" style="display: none;">
                    <h2 class="section-title">Divide Plot</h2>
                    <div class="form-group">
                        <div class="sides-grid">
                            <div>
                                <label for="numParts">Number of Parts (2-10)</label>
                                <input type="number" id="numParts" min="2" max="10" value="2">
                            </div>
                            <div>
                                <label for="divisionType">Division Type</label>
                                <select id="divisionType">
                                    <option value="equal">Equal Area</option>
                                    <option value="percentage">Percentage-Wise</option>
                                    <option value="area">Area-Wise</option>
                                </select>
                            </div>
                            <div>
                                <label for="divisionDirection">Division Direction</label>
                                <select id="divisionDirection">
                                    <option value="horizontal">Horizontal</option>
                                    <option value="vertical">Vertical</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    <div id="divisionInputs" class="sides-grid"></div>
                    <div id="divisionError"></div>
                    <button class="btn" onclick="dividePlot()">Divide Plot</button>
                </div>
            </div>

            <div class="page" id="results">
                <div class="section">
                    <h2 class="section-title">Results</h2>
                    <div id="resultsDisplay"></div>
                </div>
            </div>

            <div class="page" id="history">
                <div class="section">
                    <h2 class="section-title">Calculation History</h2>
                    <div id="historyList"></div>
                    <button class="btn" onclick="clearHistory()">Clear History</button>
                </div>
            </div>
        </div>
    </div>

    <div id="guideModal" class="modal">
        <div class="modal-content">
            <button class="close-btn" onclick="closeGuide()">Close</button>
            <h2>PlotMaster Guide</h2>
            <p>Follow these steps to use PlotMaster:</p>
            <ul>
                <li><strong>Home:</strong> Overview and quick start.</li>
                <li><strong>Plot Editor:</strong> Configure and visualize your plot:
                    <ul>
                        <li>Enter number of sides (3-8) and unit.</li>
                        <li>Generate side inputs and enter lengths.</li>
                        <li>Calculate area and draw plot.</li>
                        <li>Divide plot into parts (equal, percentage, or area).</li>
                        <li>Use canvas controls to zoom, pan, rotate, or export.</li>
                    </ul>
                </li>
                <li><strong>Results:</strong> View detailed area calculations.</li>
                <li><strong>History:</strong> Review past calculations and reload them.</li>
            </ul>
            <p><strong>Tip:</strong> Save configurations as JSON files for later use.</p>
        </div>
    </div>

    <script>
        let canvas, ctx;
        let coordinates = [];
        let sideLengths = [];
        let scale = 1;
        let offsetX = 0;
        let offsetY = 0;
        let lastCalculatedResults = null;
        let selectedSideIndex = -1;
        let updateTimeout = null;
        let rotationCount = 0;
        let divisions = [];
        let divisionAreas = [];
        let zoomLevel = 1;
        let panX = 0;
        let panY = 0;
        let isPanning = false;
        let history = JSON.parse(localStorage.getItem('plotHistory')) || [];

        const unitFactors = {
            meters: 1,
            feet: 0.3048,
            yards: 0.9144,
            inches: 0.0254
        };

        const areaConversions = {
            'square meters': 1,
            'square feet': 10.764,
            'square yards': 1.196,
            'acres': 0.000247,
            'hectares': 0.0001
        };

        function initCanvas() {
            canvas = document.getElementById('canvas');
            canvas.width = Math.min(window.innerWidth - 40, 600);
            canvas.height = 400;
            ctx = canvas.getContext('2d');
            if (!ctx) {
                showError('Canvas initialization failed.');
                return;
            }
            clearCanvas();
            canvas.addEventListener('click', handleCanvasClick);
            canvas.addEventListener('mousedown', startPan);
            canvas.addEventListener('mousemove', pan);
            canvas.addEventListener('mouseup', endPan);
            canvas.addEventListener('mouseleave', endPan);
        }

        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const mainContent = document.getElementById('mainContent');
            sidebar.classList.toggle('hidden');
            mainContent.classList.toggle('full');
        }

        function navigateTo(pageId) {
            document.querySelectorAll('.page').forEach(page => page.classList.remove('active'));
            document.querySelectorAll('.nav-item').forEach(item => item.classList.remove('active'));
            document.getElementById(pageId).classList.add('active');
            document.querySelector(`.nav-item[data-page="${pageId}"]`).classList.add('active');
            document.getElementById('pageTitle').textContent = {
                home: 'Welcome to PlotMaster',
                editor: 'Plot Editor',
                results: 'Results',
                history: 'Calculation History'
            }[pageId];
            if (pageId === 'results' && lastCalculatedResults) {
                displayResults(lastCalculatedResults.areaInUnits, lastCalculatedResults.unit, lastCalculatedResults.areaInSquareMeters);
            }
            if (pageId === 'history') {
                displayHistory();
            }
            toggleSidebar();
        }

        function generateSideInputs() {
            const numSides = parseInt(document.getElementById('numSides').value);
            const container = document.getElementById('sideInputs');
            const errorDiv = document.getElementById('errorMessage');

            errorDiv.innerHTML = '';
            document.getElementById('divisionSection').style.display = 'none';
            divisions = [];
            divisionAreas = [];

            if (numSides < 3 || numSides > 8 || isNaN(numSides)) {
                showError('Please enter a number between 3 and 8 sides.');
                return;
            }

            container.innerHTML = '';
            sideLengths = new Array(numSides).fill(100);

            for (let i = 1; i <= numSides; i++) {
                const sideGroup = document.createElement('div');
                sideGroup.className = 'side-group';
                sideGroup.innerHTML = `
                    <label>Side ${i}</label>
                    <input type="number" id="side${i}" step="0.01" min="0.1" value="100">
                `;
                container.appendChild(sideGroup);
                document.getElementById(`side${i}`).addEventListener('input', () => {
                    sideLengths[i-1] = parseFloat(document.getElementById(`side${i}`).value) || 0;
                    saveState();
                    debounceUpdatePlot();
                });
            }
            saveState();
        }

        function generateDivisionInputs() {
            const numParts = parseInt(document.getElementById('numParts').value);
            const divisionType = document.getElementById('divisionType').value;
            const container = document.getElementById('divisionInputs');
            const errorDiv = document.getElementById('divisionError');
            const unit = document.getElementById('unit').value;

            errorDiv.innerHTML = '';

            if (numParts < 2 || numParts > 10 || isNaN(numParts)) {
                showError('Please enter a number between 2 and 10 parts.', 'divisionError');
                return;
            }

            container.innerHTML = '';
            divisionAreas = new Array(numParts).fill(0);

            for (let i = 1; i <= numParts; i++) {
                const divGroup = document.createElement('div');
                divGroup.className = 'side-group';
                let inputHTML = '';
                if (divisionType === 'percentage') {
                    inputHTML = `
                        <label>Part ${i} Percentage</label>
                        <input type="number" id="part${i}" step="0.01" min="0.1" value="${(100/numParts).toFixed(2)}">
                    `;
                } else if (divisionType === 'area') {
                    inputHTML = `
                        <label>Part ${i} Area (sq ${unit})</label>
                        <input type="number" id="part${i}" step="0.01" min="0.1" value="${(lastCalculatedResults.areaInUnits/numParts).toFixed(2)}">
                    `;
                } else {
                    return;
                }
                divGroup.innerHTML = inputHTML;
                container.appendChild(divGroup);
                document.getElementById(`part${i}`).addEventListener('input', () => {
                    divisionAreas[i-1] = parseFloat(document.getElementById(`part${i}`).value) || 0;
                    saveState();
                    debounceDividePlot();
                });
            }
            saveState();
        }

        function saveState() {
            const state = {
                numSides: document.getElementById('numSides').value,
                unit: document.getElementById('unit').value,
                sideLengths,
                numParts: document.getElementById('numParts').value,
                divisionType: document.getElementById('divisionType').value,
                divisionDirection: document.getElementById('divisionDirection').value,
                divisionAreas
            };
            localStorage.setItem('plotState', JSON.stringify(state));
        }

        function loadState() {
            const state = JSON.parse(localStorage.getItem('plotState'));
            if (state) {
                document.getElementById('numSides').value = state.numSides;
                document.getElementById('unit').value = state.unit;
                document.getElementById('numParts').value = state.numParts;
                document.getElementById('divisionType').value = state.divisionType;
                document.getElementById('divisionDirection').value = state.divisionDirection;
                sideLengths = state.sideLengths || [];
                divisionAreas = state.divisionAreas || [];
                generateSideInputs();
                if (sideLengths.length > 0) {
                    for (let i = 1; i <= sideLengths.length; i++) {
                        document.getElementById(`side${i}`).value = sideLengths[i-1];
                    }
                    calculateAndDraw();
                    generateDivisionInputs();
                    for (let i = 1; i <= divisionAreas.length; i++) {
                        const input = document.getElementById(`part${i}`);
                        if (input) input.value = divisionAreas[i-1];
                    }
                }
            }
        }

        function saveConfig() {
            const config = {
                numSides: parseInt(document.getElementById('numSides').value),
                unit: document.getElementById('unit').value,
                sideLengths,
                numParts: divisions.length > 0 ? parseInt(document.getElementById('numParts').value) : null,
                divisionType: divisions.length > 0 ? document.getElementById('divisionType').value : null,
                divisionDirection: divisions.length > 0 ? document.getElementById('divisionDirection').value : null,
                divisionAreas
            };
            const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'plot-config.json';
            link.click();
        }

        function importConfig() {
            document.getElementById('importFile').click();
        }

        document.getElementById('importFile').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const config = JSON.parse(e.target.result);
                        document.getElementById('numSides').value = config.numSides;
                        document.getElementById('unit').value = config.unit;
                        sideLengths = config.sideLengths;
                        generateSideInputs();
                        for (let i = 1; i <= sideLengths.length; i++) {
                            document.getElementById(`side${i}`).value = sideLengths[i-1];
                        }
                        calculateAndDraw();
                        if (config.numParts) {
                            document.getElementById('numParts').value = config.numParts;
                            document.getElementById('divisionType').value = config.divisionType;
                            document.getElementById('divisionDirection').value = config.divisionDirection;
                            divisionAreas = config.divisionAreas;
                            generateDivisionInputs();
                            for (let i = 1; i <= divisionAreas.length; i++) {
                                document.getElementById(`part${i}`).value = divisionAreas[i-1];
                            }
                            dividePlot();
                        }
                    } catch (err) {
                        showError('Invalid configuration file.');
                    }
                };
                reader.readAsText(file);
            }
        });

        function debounceUpdatePlot() {
            clearTimeout(updateTimeout);
            updateTimeout = setTimeout(updatePlot, 300);
        }

        function debounceDividePlot() {
            clearTimeout(updateTimeout);
            updateTimeout = setTimeout(dividePlot, 300);
        }

        function constructPolygonFromSides(sides) {
            const numSides = sides.length;
            if (numSides < 3) return [];
            
            const coords = [{ x: 0, y: 0 }];
            let currentAngle = 0;
            
            for (let i = 0; i < numSides; i++) {
                const lastPoint = coords[coords.length - 1];
                const sideLength = sides[i];
                const angleStep = (2 * Math.PI) / numSides;
                currentAngle += angleStep;
                
                const newX = lastPoint.x + sideLength * Math.cos(currentAngle);
                const newY = lastPoint.y + sideLength * Math.sin(currentAngle);
                coords.push({ x: newX, y: newY });
            }
            
            if (coords.length === numSides + 1) {
                coords.pop(); // Remove last point to keep numSides points
            }
            
            return coords;
        }

        function rotateCoordinates(coords) {
            return coords.map(coord => ({
                x: coord.y,
                y: -coord.x
            }));
        }

        function rotatePlot() {
            if (coordinates.length < 3) {
                showError('No valid plot to rotate.');
                return;
            }
            
            sideLengths = [sideLengths[sideLengths.length - 1], ...sideLengths.slice(0, -1)];
            for (let i = 1; i <= sideLengths.length; i++) {
                document.getElementById(`side${i}`).value = sideLengths[i - 1];
            }
            
            coordinates = rotateCoordinates(coordinates);
            rotationCount = (rotationCount + 1) % 4;
            saveState();
            updatePlot();
        }

        function zoomIn() {
            zoomLevel *= 1.2;
            drawPlot();
        }

        function zoomOut() {
            zoomLevel = Math.max(0.5, zoomLevel / 1.2);
            drawPlot();
        }

        function startPan(event) {
            isPanning = true;
            startX = event.clientX;
            startY = event.clientY;
        }

        function pan(event) {
            if (isPanning) {
                const dx = event.clientX - startX;
                const dy = event.clientY - startY;
                panX += dx / zoomLevel;
                panY += dy / zoomLevel;
                startX = event.clientX;
                startY = event.clientY;
                drawPlot();
            }
        }

        function endPan() {
            isPanning = false;
        }

        function calculateArea(coords) {
            if (coords.length < 3) return 0;
            let area = 0;
            const n = coords.length;
            for (let i = 0; i < n; i++) {
                const j = (i + 1) % n;
                area += coords[i].x * coords[j].y;
                area -= coords[j].x * coords[i].y;
            }
            return Math.abs(area) / 2;
        }

        function validatePolygonClosure(sides) {
            const numSides = sides.length;
            const totalLength = sides.reduce((sum, length) => sum + length, 0);
            const maxSide = Math.max(...sides);
            
            if (sides.some(side => side < 0.01 || side > 1000000)) return false;
            if (maxSide >= (totalLength - maxSide)) return false;
            
            for (let i = 0; i < numSides; i++) {
                const side = sides[i];
                const otherSidesSum = totalLength - side;
                if (side >= otherSidesSum) return false;
            }
            
            return true;
        }

        function calculateAndDraw() {
            const numSides = parseInt(document.getElementById('numSides').value);
            const unit = document.getElementById('unit').value;
            const errorDiv = document.getElementById('errorMessage');
            
            errorDiv.innerHTML = '';
            sideLengths = [];
            
            for (let i = 1; i <= numSides; i++) {
                const length = parseFloat(document.getElementById(`side${i}`).value);
                if (isNaN(length) || length <= 0) {
                    showError('Please fill in all side lengths with positive numbers.');
                    return;
                }
                sideLengths.push(length);
            }
            
            if (sideLengths.length < 3) {
                showError('At least 3 sides are required.');
                return;
            }
            
            if (!validatePolygonClosure(sideLengths)) {
                showError('These side lengths cannot form a closed polygon.');
                return;
            }
            
            coordinates = constructPolygonFromSides(sideLengths);
            if (coordinates.length < 3) {
                showError('Could not construct a valid polygon.');
                return;
            }
            
            const areaInUnits = calculateArea(coordinates);
            const unitFactor = unitFactors[unit];
            const areaInSquareMeters = areaInUnits * unitFactor * unitFactor;
            
            if (areaInUnits < 0.0001) {
                showError('The calculated area is very small.');
            }
            
            lastCalculatedResults = { areaInUnits, unit, areaInSquareMeters };
            divisions = [];
            divisionAreas = [];
            document.getElementById('divisionSection').style.display = 'block';
            generateDivisionInputs();
            
            drawPlot();
            displayResults(areaInUnits, unit, areaInSquareMeters);
            saveToHistory();
            saveState();
            navigateTo('results');
        }

        function dividePlot() {
            const numParts = parseInt(document.getElementById('numParts').value);
            const divisionType = document.getElementById('divisionType').value;
            const divisionDirection = document.getElementById('divisionDirection').value;
            const errorDiv = document.getElementById('divisionError');
            errorDiv.innerHTML = '';
            
            if (!lastCalculatedResults) {
                showError('Please calculate the plot area first.', 'divisionError');
                return;
            }
            
            if (numParts < 2 || numParts > 10 || isNaN(numParts)) {
                showError('Please enter a number between 2 and 10 parts.', 'divisionError');
                return;
            }
            
            divisionAreas = [];
            let total = 0;
            if (divisionType === 'percentage') {
                for (let i = 1; i <= numParts; i++) {
                    const percentage = parseFloat(document.getElementById(`part${i}`).value);
                    if (isNaN(percentage) || percentage <= 0) {
                        showError('Please fill in all percentages with positive numbers.', 'divisionError');
                        return;
                    }
                    divisionAreas.push(percentage / 100 * lastCalculatedResults.areaInUnits);
                    total += percentage;
                }
                if (Math.abs(total - 100) > 0.01) {
                    showError('Percentages must sum to 100%.', 'divisionError');
                    return;
                }
            } else if (divisionType === 'area') {
                for (let i = 1; i <= numParts; i++) {
                    const area = parseFloat(document.getElementById(`part${i}`).value);
                    if (isNaN(area) || area <= 0) {
                        showError('Please fill in all areas with positive numbers.', 'divisionError');
                        return;
                    }
                    divisionAreas.push(area);
                    total += area;
                }
                if (Math.abs(total - lastCalculatedResults.areaInUnits) > 0.01) {
                    showError('Areas must sum to the total plot area.', 'divisionError');
                    return;
                }
            } else {
                divisionAreas = new Array(numParts).fill(lastCalculatedResults.areaInUnits / numParts);
            }
            
            divisions = calculateDivisions(divisionAreas, divisionDirection);
            drawPlot();
            displayResults(lastCalculatedResults.areaInUnits, lastCalculatedResults.unit, lastCalculatedResults.areaInSquareMeters);
            saveToHistory();
            saveState();
        }

        function calculateDivisions(areas, direction) {
            const divisions = [];
            let accumulatedArea = 0;
            const totalArea = lastCalculatedResults.areaInUnits;
            
            const minX = Math.min(...coordinates.map(c => c.x));
            const maxX = Math.max(...coordinates.map(c => c.x));
            const minY = Math.min(...coordinates.map(c => c.y));
            const maxY = Math.max(...coordinates.map(c => c.y));
            
            if (direction === 'horizontal') {
                const height = maxY - minY;
                const areaPerUnitHeight = totalArea / height;
                let currentY = minY;
                
                for (let i = 0; i < areas.length - 1; i++) {
                    accumulatedArea += areas[i];
                    const targetArea = accumulatedArea;
                    const targetHeight = targetArea / areaPerUnitHeight;
                    currentY = minY + targetHeight;
                    const intersections = findIntersectionsWithY(currentY);
                    if (intersections.length >= 2) {
                        intersections.sort((a, b) => a.x - b.x);
                        divisions.push({
                            start: intersections[0],
                            end: intersecting[intersections.length - 1]
                        });
                    }
                }
            } else {
                const width = maxX - minX;
                const areaPerUnitWidth = totalArea / width;
                let currentX = minX;
                
                for (let i = 0; i < areas.length - 1; i++) {
                    accumulatedArea += areas[i];
                    const targetArea = accumulatedArea;
                    const targetWidth = targetArea / areaPerUnitWidth;
                    currentX = minX + targetWidth;
                    const intersections = findIntersectionsWithX(currentX);
                    if (intersections.length >= 2) {
                        intersections.sort((a, b) => a.y - b.y);
                        divisions.push({
                            start: intersections[0],
                            end: intersections[intersections.length - 1]
                        });
                    }
                }
            }
            
            return divisions;
        }

        function findIntersectionsWithY(y) {
            const intersections = [];
            for (let i = 0; i < coordinates.length; i++) {
                const p1 = coordinates[i];
                const p2 = coordinates[(i + 1) % coordinates.length];
                const minY = Math.min(p1.y, p2.y);
                const maxY = Math.max(p1.y, p2.y);
                
                if (y > minY && y <= maxY) {
                    const x = p1.x + (y - p1.y) * (p2.x - p1.x) / (p2.y - p1.y);
                    intersections.push({ x, y });
                }
            }
            return intersections;
        }

        function findIntersectionsWithX(x) {
            const intersections = [];
            for (let i = 0; i < coordinates.length; i++) {
                const p1 = coordinates[i];
                const p2 = coordinates[(i + 1) % coordinates.length];
                const minX = Math.min(p1.x, p2.x);
                const maxX = Math.max(p1.x, p2.x);
                
                if (x > minX && x <= maxX) {
                    const y = p1.y + (x - p1.x) * (p2.y - p1.y) / (p2.x - p1.x);
                    intersections.push({ x, y });
                }
            }
            return intersections;
        }

        function updatePlot() {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.innerHTML = '';
            
            if (sideLengths.some(length => length <= 0 || isNaN(length))) {
                return;
            }
            
            if (!validatePolygonClosure(sideLengths)) {
                showError('These side lengths cannot form a closed polygon.');
                return;
            }
            
            coordinates = constructPolygonFromSides(sideLengths);
            if (coordinates.length < 3) {
                showError('Could not construct a valid polygon.');
                return;
            }
            
            const unit = document.getElementById('unit').value;
            const areaInUnits = calculateArea(coordinates);
            const unitFactor = unitFactors[unit];
            const areaInSquareMeters = areaInUnits * unitFactor * unitFactor;

            
            lastCalculatedResults = { areaInUnits, unit, areaInSquareMeters };
            divisions = [];
            divisionAreas = [];
            document.getElementById('divisionSection').style.display = 'block';
            generateDivisionInputs();
            
            drawPlot();
            displayResults(areaInUnits, unit, areaInSquareMeters);
            saveToHistory();
            saveState();
        }

        function drawPlot() {
            if (!ctx) return;
            clearCanvas(false);
            
            if (coordinates.length < 3) return;
            
            const minX = Math.min(...coordinates.map(c => c.x));
            const maxX = Math.max(...coordinates.map(c => c.x));
            const minY = Math.min(...coordinates.map(c => c.y));
            const maxY = Math.max(...coordinates.map(c => c.y));
            
            const width = maxX - minX || 1;
            const height = maxY - minY || 1;
            const padding = 20;
            const scaleX = (canvas.width - 2 * padding) / width;
            const scaleY = (canvas.height - 2 * padding) / height;
            scale = Math.min(scaleX, scaleY, 50) * zoomLevel;
            
            offsetX = (canvas.width - width * scale) / 2 - minX * scale + panX;
            offsetY = (canvas.height - height * scale) / 2 - minY * scale + panY;
            
            drawGrid();
            
            ctx.beginPath();
            ctx.strokeStyle = '#3b82f6';
            ctx.fillStyle = 'rgba(59, 130, 246, 0.2)';
            ctx.lineWidth = 3;
            coordinates.forEach((coord, index) => {
                const x = coord.x * scale + offsetX;
                const y = canvas.height - (coord.y * scale + offsetY);
                if (index === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            coordinates.forEach((coord, index) => {
                const x = coord.x * scale + offsetX;
                const y = canvas.height - (coord.y * scale + offsetY);
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, 2 * Math.PI);
                ctx.fillStyle = '#ef4444';
                ctx.fill();
                ctx.fillStyle = '#1f2937';
                ctx.font = 'bold 12px Inter';
                ctx.fillText(`P${index + 1}`, x + 8, y - 8);
            });
            
            for (let i = 0; i < coordinates.length; i++) {
                const current = coordinates[i];
                const next = coordinates[(i + 1) % coordinates.length];
                const sideLength = sideLengths[i];
                const x1 = current.x * scale + offsetX;
                const y1 = canvas.height - (current.y * scale + offsetY);
                const x2 = next.x * scale + offsetX;
                const y2 = canvas.height - (next.y * scale + offsetY);
                const midX = (x1 + x2) / 2;
                const midY = (y1 + y2) / 2;
                const rectWidth = Math.max(30, 30 * scale / 50);
                const rectHeight = Math.max(20, 20 * scale / 50);
                
                ctx.fillStyle = i === selectedSideIndex ? 'rgba(255, 255, 0, 0.5)' : 'rgba(255, 255, 255, 0.9)';
                ctx.fillRect(midX - rectWidth / 2, midY - rectHeight / 2, rectWidth, rectHeight);
                ctx.fillStyle = '#059669';
                ctx.font = 'bold 12px Inter';
                ctx.textAlign = 'center';
                ctx.fillText(`S${i + 1}: ${sideLength.toFixed(2)}`, midX, midY + 4);
                ctx.textAlign = 'left';
            }
            
            if (divisions.length > 0) {
                divisions.forEach((division, index) => {
                    ctx.beginPath();
                    ctx.strokeStyle = '#ef4444';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    const x1 = division.start.x * scale + offsetX;
                    const y1 = canvas.height - (division.start.y * scale + offsetY);
                    const x2 = division.end.x * scale + offsetX;
                    const y2 = canvas.height - (division.end.y * scale + offsetY);
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    const midX = (x1 + x2) / 2;
                    const midY = (y1 + y2) / 2;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.fillRect(midX - 20, midY - 10, 40, 20);
                    ctx.fillStyle = '#ef4444';
                    ctx.font = 'bold 12px Inter';
                    ctx.textAlign = 'center';
                    ctx.fillText(`D${index + 1}`, midX, midY + 4);
                    ctx.textAlign = 'left';
                });
            }
        }

        function drawGrid() {
            if (!ctx) return;
            ctx.strokeStyle = '#d1d5db';
            ctx.lineWidth = 1;
            const gridSpacing = Math.max(10, 20 / scale);
            for (let x = 0; x <= canvas.width; x += gridSpacing * scale) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= canvas.height; y += gridSpacing * scale) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        function handleCanvasClick(event) {
            const rect = canvas.getBoundingClientRect();
            const x = (event.clientX - rect.left - panX) / zoomLevel;
            const y = (event.clientY - rect.top - panY) / zoomLevel;
            
            for (let i = 0; i < coordinates.length; i++) {
                const current = coordinates[i];
                const next = coordinates[(i + 1) % coordinates.length];
                const x1 = current.x * scale + offsetX;
                const y1 = canvas.height - (current.y * scale + offsetY);
                const x2 = next.x * scale + offsetX;
                const y2 = canvas.height - (next.y * scale + offsetY);
                const midX = (x1 + x2) / 2;
                const midY = (y1 + y2) / 2;
                const rectWidth = Math.max(30, 30 * scale / 50);
                const rectHeight = Math.max(20, 20 * scale / 50);
                
                if (x >= midX - rectWidth / 2 && x <= midX + rectWidth / 2 && 
                    y >= midY - rectHeight / 2 && y <= midY + rectHeight / 2) {
                    selectedSideIndex = i;
                    const newLength = prompt(`Enter length for Side ${i + 1} (S${i + 1}):`, sideLengths[i]);
                    if (newLength !== null) {
                        const parsedLength = parseFloat(newLength);
                        if (!isNaN(parsedLength) && parsedLength > 0) {
                            sideLengths[i] = parsedLength;
                            document.getElementById(`side${i + 1}`).value = parsedLength;
                            saveState();
                            updatePlot();
                        } else {
                            alert('Please enter a valid positive number.');
                        }
                    }
                    drawPlot();
                    break;
                }
            }
        }

        function displayResults(areaInUnits, unit, areaInSquareMeters) {
            const resultsDiv = document.getElementById('resultsDisplay');
            let conversionsHTML = '';
            for (const [convertUnit, factor] of Object.entries(areaConversions)) {
                const convertedArea = areaInSquareMeters * factor;
                conversionsHTML += `
                    <div class="unit-conversion">
                        <strong>${convertedArea.toFixed(4)}</strong> ${convertUnit}
                    </div>
                `;
            }
            
            const totalPerimeter = sideLengths.reduce((sum, length) => sum + length, 0);
            let divisionHTML = '';
            if (divisions.length > 0) {
                const divisionType = document.getElementById('divisionType').value;
                const divisionDirection = document.getElementById('divisionDirection').value;
                divisionHTML = `<h3>Divided Areas (${divisionDirection})</h3>`;
                divisionAreas.forEach((area, index) => {
                    let label = `Part ${index + 1}: ${area.toFixed(4)} sq ${unit}`;
                    if (divisionType === 'percentage') {
                        const percentage = (area / areaInUnits * 100).toFixed(2);
                        label += ` (${percentage}%)`;
                    }
                    divisionHTML += `<p><strong>${label}</strong></p>`;
                });
            }
            
            resultsDiv.innerHTML = `
                <div class="results">
                    <h3>Calculated Areas</h3>
                    <p><strong>Area:</strong> ${areaInUnits.toFixed(4)} sq ${unit}</p>
                    <p><strong>Perimeter:</strong> ${totalPerimeter.toFixed(2)} ${unit}</p>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 8px;">
                        ${conversionsHTML}
                    </div>
                    ${divisionHTML}
                </div>
            `;
        }

        function saveToHistory() {
            const historyEntry = {
                timestamp: new Date().toISOString(),
                sideLengths: [...sideLengths],
                unit: document.getElementById('unit').value,
                areaInUnits: lastCalculatedResults?.areaInUnits,
                areaInSquareMeters: lastCalculatedResults?.areaInSquareMeters,
                divisions: [...divisions],
                divisionAreas: [...divisionAreas],
                divisionType: document.getElementById('divisionType').value,
                divisionDirection: document.getElementById('divisionDirection').value
            };
            history.unshift(historyEntry);
            if (history.length > 50) history.pop();
            localStorage.setItem('plotHistory', JSON.stringify(history));
            displayHistory();
        }

        function displayHistory() {
            const historyList = document.getElementById('historyList');
            historyList.innerHTML = '';
            history.forEach((entry, index) => {
                const item = document.createElement('div');
                item.className = 'history-item';
                item.innerHTML = `
                    <p><strong>Calculation ${index + 1}</strong> - ${new Date(entry.timestamp).toLocaleString()}</p>
                    <p>Area: ${entry.areaInUnits?.toFixed(4)} sq ${entry.unit}</p>
                    <p>Sides: ${entry.sideLengths.join(', ')}</p>
                `;
                item.onclick = () => loadHistoryEntry(index);
                historyList.appendChild(item);
            });
        }

        function loadHistoryEntry(index) {
            const entry = history[index];
            document.getElementById('numSides').value = entry.sideLengths.length;
            document.getElementById('unit').value = entry.unit;
            sideLengths = entry.sideLengths;
            generateSideInputs();
            for (let i = 1; i <= sideLengths.length; i++) {
                document.getElementById(`side${i}`).value = sideLengths[i-1];
            }
            calculateAndDraw();
            if (entry.divisions.length > 0) {
                document.getElementById('numParts').value = entry.divisionAreas.length;
                document.getElementById('divisionType').value = entry.divisionType;
                document.getElementById('divisionDirection').value = entry.divisionDirection;
                divisionAreas = entry.divisionAreas;
                generateDivisionInputs();
                for (let i = 1; i <= divisionAreas.length; i++) {
                    document.getElementById(`part${i}`).value = divisionAreas[i-1];
                }
                divisions = entry.divisions;
                drawPlot();
                displayResults(entry.areaInUnits, entry.unit, entry.areaInSquareMeters);
            }
            navigateTo('editor');
        }

        function clearHistory() {
            history = [];
            localStorage.setItem('plotHistory', JSON.stringify(history));
            displayHistory();
        }

        function clearCanvas(hideResults = true) {
            if (!ctx) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (hideResults) {
                document.getElementById('resultsDisplay').innerHTML = '';
                document.getElementById('divisionSection').style.display = 'none';
                lastCalculatedResults = null;
                sideLengths = [];
                coordinates = [];
                divisions = [];
                divisionAreas = [];
                selectedSideIndex = -1;
                rotationCount = 0;
                zoomLevel = 1;
                panX = 0;
                panY = 0;
            }
            saveState();
        }

        function downloadCanvas() {
            if (!ctx) return;
            ctx.save();
            ctx.font = '10px Inter';
            ctx.fillStyle = '#1f2937';
            ctx.textAlign = 'right';
            ctx.fillText('Generated by PlotMaster | unifyxproject.netlify.app', canvas.width - 10, canvas.height - 10);
            
            const link = document.createElement('a');
            link.download = 'plot-master.png';
            link.href = canvas.toDataURL('image/png', 1.0);
            link.click();
            
            ctx.restore();
            drawPlot();
        }

        function downloadResultsAsPDF() {
            if (!window.jspdf) {
                showError('PDF library not loaded.');
                return;
            }
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({
                orientation: 'portrait',
                unit: 'mm',
                format: 'a4'
            });

            doc.setFillColor(59, 130, 246);
            doc.rect(0, 0, 210, 30, 'F');
            doc.setFontSize(18);
            doc.setTextColor(255, 255, 255);
            doc.setFont('helvetica', 'bold');
            doc.text('PlotMaster Area Report', 10, 15);
            doc.setFontSize(12);
            doc.text(`Generated: ${new Date().toLocaleString()}`, 10, 25);

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width * 2;
            tempCanvas.height = canvas.height * 2;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.scale(2, 2);
            tempCtx.translate(canvas.width / 2 + panX, canvas.height / 2 + panY);
            tempCtx.rotate(rotationCount * Math.PI / 2);
            tempCtx.translate(-canvas.width / 2, -canvas.height / 2);
            
            tempCtx.fillStyle = '#ffffff';
            tempCtx.fillRect(0, 0, canvas.width, canvas.height);
            drawGridOnCanvas(tempCtx);
            
            tempCtx.beginPath();
            tempCtx.strokeStyle = '#3b82f6';
            tempCtx.fillStyle = 'rgba(59, 130, 246, 0.2)';
            tempCtx.lineWidth = 3;
            coordinates.forEach((coord, index) => {
                const x = coord.x * scale + offsetX;
                const y = canvas.height - (coord.y * scale + offsetY);
                if (index === 0) tempCtx.moveTo(x, y);
                else tempCtx.lineTo(x, y);
            });
            tempCtx.closePath();
            tempCtx.fill();
            tempCtx.stroke();
            
            coordinates.forEach((coord, index) => {
                const x = coord.x * scale + offsetX;
                const y = canvas.height - (coord.y * scale + offsetY);
                tempCtx.beginPath();
                tempCtx.arc(x, y, 4, 0, 2 * Math.PI);
                tempCtx.fillStyle = '#ef4444';
                tempCtx.fill();
                tempCtx.fillStyle = '#1f2937';
                tempCtx.font = 'bold 12px Inter';
                tempCtx.fillText(`P${index + 1}`, x + 8, y - 8);
            });
            
            for (let i = 0; i < coordinates.length; i++) {
                const current = coordinates[i];
                const next = coordinates[(i + 1) % coordinates.length];
                const sideLength = sideLengths[i];
                const x1 = current.x * scale + offsetX;
                const y1 = canvas.height - (current.y * scale + offsetY);
                const x2 = next.x * scale + offsetX;
                const y2 = canvas.height - (next.y * scale + offsetY);
                const midX = (x1 + x2) / 2;
                const midY = (y1 + y2) / 2;
                const rectWidth = Math.max(30, 30 * scale / 50);
                const rectHeight = Math.max(20, 20 * scale / 50);
                tempCtx.fillStyle = i === selectedSideIndex ? 'rgba(255, 255, 0, 0.5)' : 'rgba(255, 255, 255, 0.9)';
                tempCtx.fillRect(midX - rectWidth / 2, midY - rectHeight / 2, rectWidth, rectHeight);
                tempCtx.fillStyle = '#059669';
                tempCtx.font = 'bold 12px Inter';
                tempCtx.textAlign = 'center';
                tempCtx.fillText(`S${i + 1}: ${sideLength.toFixed(2)}`, midX, midY + 4);
                tempCtx.textAlign = 'left';
            }
            
            if (divisions.length > 0) {
                divisions.forEach((division, index) => {
                    tempCtx.beginPath();
                    tempCtx.strokeStyle = '#ef4444';
                    tempCtx.lineWidth = 2;
                    tempCtx.setLineDash([5, 5]);
                    const x1 = division.start.x * scale + offsetX;
                    const y1 = canvas.height - (division.start.y * scale + offsetY);
                    const x2 = division.end.x * scale + offsetX;
                    const y2 = canvas.height - (division.end.y * scale + offsetY);
                    tempCtx.moveTo(x1, y1);
                    tempCtx.lineTo(x2, y2);
                    tempCtx.stroke();
                    tempCtx.setLineDash([]);
                    
                    const midX = (x1 + x2) / 2;
                    const midY = (y1 + y2) / 2;
                    tempCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    tempCtx.fillRect(midX - 20, midY - 10, 40, 20);
                    tempCtx.fillStyle = '#ef4444';
                    tempCtx.font = 'bold 12px Inter';
                    tempCtx.textAlign = 'center';
                    tempCtx.fillText(`D${index + 1}`, midX, midY + 4);
                    tempCtx.textAlign = 'left';
                });
            }
            
            tempCtx.font = '10px Inter';
            tempCtx.fillStyle = '#1f2937';
            tempCtx.textAlign = 'right';
            tempCtx.fillText('Generated by PlotMaster | unifyxproject.netlify.app', canvas.width - 10, canvas.height - 10);
            
            const imgData = tempCanvas.toDataURL('image/png', 1.0);
            doc.addImage(imgData, 'PNG', 10, 35, 190, 152);
            
            if (lastCalculatedResults) {
                const { areaInUnits, unit, areaInSquareMeters } = lastCalculatedResults;
                const totalPerimeter = sideLengths.reduce((sum, length) => sum + length, 0);

                doc.setFillColor(243, 244, 246);
                doc.rect(10, 195, 190, divisions.length > 0 ? 100 : 85, 'F');
                doc.setDrawColor(59, 130, 246);
                doc.setLineWidth(0.5);
                doc.rect(10, 195, 190, divisions.length > 0 ? 100 : 85);

                doc.setFontSize(14);
                doc.setTextColor(31, 41, 55);
                doc.setFont('helvetica', 'bold');
                doc.text('Calculated Results', 15, 205);

                doc.setFontSize(12);
                doc.setTextColor(0, 0, 0);
                doc.text(`Area: ${areaInUnits.toFixed(4)} square ${unit}`, 15, 215);
                doc.text(`Perimeter: ${totalPerimeter.toFixed(2)} ${unit}`, 15, 225);

                let yOffset = 235;
                doc.setFontSize(10);
                for (const [convertUnit, factor] of Object.entries(areaConversions)) {
                    if (yOffset >= 270) break;
                    const convertedArea = areaInSquareMeters * factor;
                    doc.setFillColor(255, 255, 255);
                    doc.roundedRect(15, yOffset - 4, 80, 10, 2, 2, 'F');
                    doc.setTextColor(0, 0, 0);
                    doc.text(`${convertedArea.toFixed(4)} ${convertUnit}`, 20, yOffset + 4);
                    yOffset += 12;
                }

                if (divisions.length > 0) {
                    doc.setFontSize(12);
                    doc.setTextColor(31, 41, 55);
                    const divisionDirection = document.getElementById('divisionDirection').value;
                    doc.text(`Divided Areas (${divisionDirection})`, 15, yOffset);
                    yOffset += 10;
                    doc.setFontSize(10);
                    const divisionType = document.getElementById('divisionType').value;
                    divisionAreas.forEach((area, index) => {
                        let label = `Part ${index + 1}: ${area.toFixed(4)} sq ${unit}`;
                        if (divisionType === 'percentage') {
                            const percentage = (area / areaInUnits * 100).toFixed(2);
                            label += ` (${percentage}%)`;
                        }
                        doc.text(label, 20, yOffset + 4);
                        yOffset += 10;
                    });
                }
            } else {
                doc.setFontSize(12);
                doc.setTextColor(239, 68, 68);
                doc.text('No results available.', 10, 195);
            }

            doc.setFontSize(8);
            doc.setTextColor(31, 41, 55);
            doc.setFont('helvetica', 'normal');
            doc.text('Generated by PlotMaster | unifyxproject.netlify.app', 10, 290);

            doc.save('plot-master-report.pdf');
        }

        function drawGridOnCanvas(context) {
            context.strokeStyle = '#d1d5db';
            context.lineWidth = 1;
            const gridSpacing = Math.max(10, 20 / scale);
            for (let x = 0; x <= canvas.width; x += gridSpacing * scale) {
                context.beginPath();
                context.moveTo(x, 0);
                context.lineTo(x, canvas.height);
                context.stroke();
            }
            for (let y = 0; y <= canvas.height; y += gridSpacing * scale) {
                context.beginPath();
                context.moveTo(0, y);
                context.lineTo(canvas.width, y);
                context.stroke();
            }
        }

        function showError(message, target = 'errorMessage') {
            document.getElementById(target).innerHTML = `<div class="error">${message}</div>`;
        }

        function showGuide() {
            document.getElementById('guideModal').style.display = 'flex';
        }

        function closeGuide() {
            document.getElementById('guideModal').style.display = 'none';
        }

        window.onload = function() {
            initCanvas();
            loadState();
            displayHistory();
            document.querySelectorAll('.nav-item').forEach(item => {
                item.addEventListener('click', () => navigateTo(item.dataset.page));
            });
            document.getElementById('divisionType').addEventListener('change', generateDivisionInputs);
            document.getElementById('numSides').addEventListener('input', generateSideInputs);
            window.addEventListener('resize', () => {
                initCanvas();
                if (coordinates.length > 0) drawPlot();
            });
        };
    </script>
</body>
</html>