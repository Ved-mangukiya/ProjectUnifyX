<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Custom Plot Area Finder</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 10px;
        }
        
        .container {
            max-width: 100%;
            width: 100%;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 20px;
            text-align: center;
            position: relative;
        }
        
        .header h1 {
            font-size: clamp(1.8rem, 5vw, 2.2rem);
            margin-bottom: 8px;
        }
        
        .header p {
            font-size: clamp(0.9rem, 3vw, 1rem);
            opacity: 0.9;
        }
        
        .guide-btn {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: #ffffff;
            color: #4facfe;
            border: 2px solid #4facfe;
            padding: 8px 15px;
            border-radius: 8px;
            font-size: clamp(0.8rem, 2.5vw, 0.9rem);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .guide-btn:hover {
            background: #4facfe;
            color: white;
        }
        
        .main-content {
            display: flex;
            flex-direction: column;
            gap: 20px;
            padding: 15px;
        }
        
        .input-section, .visual-section, .division-section {
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
            border: 1px solid #e0e7ff;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 6px;
            font-weight: 600;
            color: #374151;
            font-size: clamp(0.85rem, 2.5vw, 0.9rem);
        }
        
        input, select {
            width: 100%;
            padding: 10px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: clamp(0.9rem, 2.5vw, 1rem);
            background: #f9fafb;
            transition: all 0.3s ease;
        }
        
        input:focus, select:focus {
            outline: none;
            border-color: #4facfe;
            background: white;
            box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1);
        }
        
        .sides-input {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .sides-input > div {
            flex: 1;
            min-width: 120px;
        }
        
        .btn {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: clamp(0.9rem, 2.5vw, 1rem);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 10px rgba(79, 172, 254, 0.3);
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(79, 172, 254, 0.4);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .sides-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        
        .side-group {
            background: #f8fafc;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }
        
        .side-group:hover {
            border-color: #4facfe;
            box-shadow: 0 2px 8px rgba(79, 172, 254, 0.1);
        }
        
        .side-group h4 {
            color: #475569;
            margin-bottom: 8px;
            font-size: clamp(0.8rem, 2.5vw, 0.85rem);
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .side-icon {
            background: #4facfe;
            color: white;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: bold;
        }
        
        #canvas {
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            background: #fafafa;
            display: block;
            width: 100%;
            max-width: 500px;
            height: auto;
            aspect-ratio: 5 / 4;
            margin: 0 auto;
            cursor: crosshair;
        }
        
        .canvas-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 10px;
        }
        
        .canvas-controls button {
            flex: 1;
            min-width: 100px;
        }
        
        .results {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            text-align: center;
        }
        
        .results h3 {
            font-size: clamp(1.2rem, 3vw, 1.3rem);
            margin-bottom: 10px;
        }
        
        .area-display {
            font-size: clamp(1.5rem, 4vw, 1.8rem);
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        .unit-conversions {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 8px;
            margin-top: 10px;
        }
        
        .unit-conversion {
            background: rgba(255, 255, 255, 0.2);
            padding: 8px;
            border-radius: 6px;
        }
        
        .section-title {
            font-size: clamp(1.1rem, 3vw, 1.2rem);
            color: #374151;
            margin-bottom: 15px;
            font-weight: 700;
            border-bottom: 2px solid #4facfe;
            padding-bottom: 8px;
        }
        
        .error {
            background: #fee2e2;
            color: #dc2626;
            padding: 8px 12px;
            border-radius: 6px;
            margin-top: 8px;
            border: 1px solid #fecaca;
            font-size: clamp(0.85rem, 2.5vw, 0.9rem);
        }
        
        .warning {
            background: #fef3c7;
            color: #d97706;
            padding: 8px 12px;
            border-radius: 6px;
            margin-top: 8px;
            border: 1px solid #fde68a;
            font-size: clamp(0.85rem, 2.5vw, 0.9rem);
        }
        
        .division-info {
            background: #f0f9ff;
            border: 1px solid #bae6fd;
            padding: 12px;
            border-radius: 8px;
            margin-top: 12px;
        }
        
        .division-info h4 {
            color: #0369a1;
            margin-bottom: 6px;
            font-size: clamp(0.9rem, 2.5vw, 0.95rem);
        }
        
        .division-info p {
            color: #075985;
            font-size: clamp(0.8rem, 2.5vw, 0.85rem);
            line-height: 1.4;
        }
        
        footer {
            color: rgb(255, 255, 255);
            text-align: center;
            padding: 15px;
            margin-top: 15px;
            border-radius: 0 0 15px 15px;
        }
        
        footer p {
            font-size: clamp(0.8rem, 2.5vw, 0.85rem);
        }
        
        
        
       
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .modal-content {
            background: white;
            padding: 20px;
            border-radius: 10px;
            max-width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .modal-content h2 {
            font-size: clamp(1.2rem, 3vw, 1.3rem);
            margin-bottom: 15px;
        }
        
        .modal-content p, .modal-content li {
            font-size: clamp(0.85rem, 2.5vw, 0.9rem);
            margin-bottom: 10px;
            line-height: 1.5;
        }
        
        .close-btn {
            background: #dc2626;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 8px;
            cursor: pointer;
            float: right;
        }
        
        @media (min-width: 768px) {
            .container {
                max-width: 1200px;
            }
            .main-content {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 20px;
                padding: 20px;
            }
            .division-section {
                grid-column: span 2;
            }
            #canvas {
                max-width: 600px;
            }
            .modal-content {
                max-width: 600px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üßÆ Custom Plot Area Finder</h1>
            <p>Calculate and divide the area of irregular land plots</p>
            <button class="guide-btn" onclick="showGuide()">üìñ Guide</button>
        </div>
        
        <div class="main-content">
            <div class="input-section">
                <h2 class="section-title">üìê Plot Configuration</h2>
                
                <div class="form-group">
                    <div class="sides-input">
                        <div>
                            <label for="numSides">Number of Sides (3-8)</label>
                            <input type="number" id="numSides" min="3" max="8" value="4" placeholder="Enter number of sides">
                        </div>
                        <div>
                            <label for="unit">Unit</label>
                            <select id="unit">
                                <option value="meters">Meters</option>
                                <option value="feet">Feet</option>
                                <option value="yards">Yards</option>
                                <option value="inches">Inches</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <div class="form-group">
                    <button class="btn" onclick="generateSideInputs()">Generate Side Input Fields</button>
                </div>
                
                <div id="sideInputs" class="sides-grid"></div>
                
                <div class="form-group" style="margin-top: 20px;">
                    <button class="btn" onclick="calculateAndDraw()" style="width: 100%;">üìä Calculate Area & Draw Plot</button>
                </div>
                
                <div id="errorMessage"></div>
            </div>
            
            <div class="visual-section">
                <h2 class="section-title">üìà Visual Plot</h2>
                
                <div class="canvas-controls">
                    <button class="btn" onclick="clearCanvas()">üóëÔ∏è Clear</button>
                    <button class="btn" onclick="rotatePlot()">üîÑ Rotate Plot</button>
                    <button class="btn" onclick="downloadCanvas()">üíæ Download Plot</button>
                    <button class="btn" onclick="downloadResultsAsPDF()">üìÑ Download Plot with Areas</button>
                </div>
                
                <canvas id="canvas"></canvas>
                
                <div id="results" style="display: none;"></div>
            </div>
            
            <div class="division-section" id="divisionSection" style="display: none;">
                <h2 class="section-title">üß© Divide Plot</h2>
                <div class="form-group">
                    <div class="sides-input">
                        <div>
                            <label for="numParts">Number of Parts (2-10)</label>
                            <input type="number" id="numParts" min="2" max="10" value="2" placeholder="Enter number of parts">
                        </div>
                        <div>
                            <label for="divisionType">Division Type</label>
                            <select id="divisionType">
                                <option value="equal">Equal Area</option>
                                <option value="percentage">Percentage-Wise</option>
                                <option value="area">Area-Wise (e.g., sq ft, sq m)</option>
                            </select>
                        </div>
                        <div>
                            <label for="divisionDirection">Division Direction</label>
                            <select id="divisionDirection">
                                <option value="horizontal">Horizontal</option>
                                <option value="vertical">Vertical</option>
                            </select>
                        </div>
                    </div>
                </div>
                <div id="divisionInputs" class="sides-grid"></div>
                <div class="form-group" style="margin-top: 20px;">
                    <button class="btn" onclick="dividePlot()" style="width: 100%;">üß© Divide Plot</button>
                </div>
                <div id="divisionError"></div>
                <div class="division-info">
                    <h4>‚ÑπÔ∏è Division Information</h4>
                    <p>Divide the plot into equal areas, specific percentages, or specific areas. Choose horizontal or vertical division. Division lines will be shown on the plot, and results will be included in the PDF.</p>
                </div>
            </div>
        </div>
    </div>

    <footer>
        <p>¬© <span id="current-year"></span> Mangukiya Ved. All rights reserved.</p>
       
    </footer>

    <div id="guideModal" class="modal">
        <div class="modal-content">
            <button class="close-btn" onclick="closeGuide()">Close</button>
            <h2>How to Use Custom Plot Area Finder</h2>
            <p>Follow these steps to calculate and divide a land plot:</p>
            <ul>
                <li><strong>Step 1:</strong> Enter the number of sides (3-8) and select a unit (e.g., meters).</li>
                <li><strong>Step 2:</strong> Click "Generate Side Input Fields" to create input fields for side lengths, pre-filled with 100 units.</li>
                <li><strong>Step 3:</strong> Enter the length for each side and click "Calculate Area & Draw Plot" to see the plot and area.</li>
                <li><strong>Step 4:</strong> In the "Divide Plot" section, select the number of parts (2-10), division type (equal, percentage, or area), and direction (horizontal or vertical).</li>
                <li><strong>Step 5:</strong> For percentage or area division, enter values for each part, ensuring they sum to 100% or the total area, respectively.</li>
                <li><strong>Step 6:</strong> Click "Divide Plot" to see division lines and area details.</li>
                <li><strong>Step 7:</strong> Use the canvas controls to rotate, download the plot image, or generate a PDF with all details.</li>
                <li><strong>Step 8:</strong> Click on a side label (S1, S2, etc.) on the canvas to edit its length directly.</li>
            </ul>
            <p><strong>Note:</strong> Ensure side lengths form a valid polygon, and division inputs are consistent with the total area.</p>
        </div>
    </div>

    <script>
        let canvas, ctx;
        let coordinates = [];
        let sideLengths = [];
        let scale = 1;
        let offsetX = 0;
        let offsetY = 0;
        let lastCalculatedResults = null;
        let selectedSideIndex = -1;
        let updateTimeout = null;
        let rotationCount = 0;
        let divisions = [];
        let divisionAreas = [];

        const unitFactors = {
            meters: 1,
            feet: 0.3048,
            yards: 0.9144,
            inches: 0.0254
        };

        const areaConversions = {
            'square meters': 1,
            'square feet': 10.764,
            'square yards': 1.196,
            'acres': 0.000247,
            'hectares': 0.0001
        };

        function initCanvas() {
            canvas = document.getElementById('canvas');
            canvas.width = Math.min(window.innerWidth - 40, 500);
            canvas.height = canvas.width * 0.8;
            ctx = canvas.getContext('2d');
            if (!ctx) {
                document.getElementById('errorMessage').innerHTML = '<div class="error">Canvas initialization failed.</div>';
                return;
            }
            clearCanvas();
            canvas.addEventListener('click', handleCanvasClick);
        }

        function generateSideInputs() {
            const numSides = parseInt(document.getElementById('numSides').value);
            const container = document.getElementById('sideInputs');
            const errorDiv = document.getElementById('errorMessage');
            
            errorDiv.innerHTML = '';
            document.getElementById('divisionSection').style.display = 'none';
            divisions = [];
            divisionAreas = [];
            
            if (numSides < 3 || numSides > 8 || isNaN(numSides)) {
                errorDiv.innerHTML = '<div class="error">Please enter a number between 3 and 8 sides.</div>';
                return;
            }
            
            container.innerHTML = '';
            sideLengths = new Array(numSides).fill(100);
            
            for (let i = 1; i <= numSides; i++) {
                const sideGroup = document.createElement('div');
                sideGroup.className = 'side-group';
                sideGroup.innerHTML = `
                    <h4><span class="side-icon">${i}</span>Side ${i} Length</h4>
                    <input type="number" id="side${i}" placeholder="Enter length" step="0.01" min="0.1" value="100">
                `;
                container.appendChild(sideGroup);
                document.getElementById(`side${i}`).addEventListener('input', () => {
                    sideLengths[i-1] = parseFloat(document.getElementById(`side${i}`).value) || 0;
                    debounceUpdatePlot();
                });
            }
        }

        function generateDivisionInputs() {
            const numParts = parseInt(document.getElementById('numParts').value);
            const divisionType = document.getElementById('divisionType').value;
            const container = document.getElementById('divisionInputs');
            const errorDiv = document.getElementById('divisionError');
            const unit = document.getElementById('unit').value;
            
            errorDiv.innerHTML = '';
            
            if (numParts < 2 || numParts > 10 || isNaN(numParts)) {
                errorDiv.innerHTML = '<div class="error">Please enter a number between 2 and 10 parts.</div>';
                return;
            }
            
            container.innerHTML = '';
            divisionAreas = new Array(numParts).fill(0);
            
            for (let i = 1; i <= numParts; i++) {
                const divGroup = document.createElement('div');
                divGroup.className = 'side-group';
                let inputHTML = '';
                if (divisionType === 'percentage') {
                    inputHTML = `
                        <h4><span class="side-icon">${i}</span>Part ${i} Percentage</h4>
                        <input type="number" id="part${i}" placeholder="Enter percentage" step="0.01" min="0.1" value="${(100/numParts).toFixed(2)}">
                    `;
                } else if (divisionType === 'area') {
                    inputHTML = `
                        <h4><span class="side-icon">${i}</span>Part ${i} Area (sq ${unit})</h4>
                        <input type="number" id="part${i}" placeholder="Enter area" step="0.01" min="0.1" value="${(lastCalculatedResults.areaInUnits/numParts).toFixed(2)}">
                    `;
                } else {
                    return;
                }
                divGroup.innerHTML = inputHTML;
                container.appendChild(divGroup);
                document.getElementById(`part${i}`).addEventListener('input', () => {
                    divisionAreas[i-1] = parseFloat(document.getElementById(`part${i}`).value) || 0;
                    debounceDividePlot();
                });
            }
        }

        function debounceUpdatePlot() {
            clearTimeout(updateTimeout);
            updateTimeout = setTimeout(updatePlot, 300);
        }

        function debounceDividePlot() {
            clearTimeout(updateTimeout);
            updateTimeout = setTimeout(dividePlot, 300);
        }

        function constructPolygonFromSides(sides) {
            const numSides = sides.length;
            if (numSides < 3) return [];
            
            const coords = [{ x: 0, y: 0 }];
            let currentAngle = 0;
            
            for (let i = 0; i < numSides - 1; i++) {
                const lastPoint = coords[coords.length - 1];
                const sideLength = sides[i];
                const angleStep = (2 * Math.PI) / numSides;
                currentAngle += angleStep;
                
                const newX = lastPoint.x + sideLength * Math.cos(currentAngle);
                const newY = lastPoint.y + sideLength * Math.sin(currentAngle);
                coords.push({ x: newX, y: newY });
            }
            
            if (coords.length === numSides) {
                const lastSide = sides[numSides - 1];
                const firstPoint = coords[0];
                const lastPoint = coords[numSides - 1];
                const dx = firstPoint.x - lastPoint.x;
                const dy = firstPoint.y - lastPoint.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (Math.abs(distance - lastSide) > 0.001) {
                    const angleToFirst = Math.atan2(dy, dx);
                    coords[numSides - 1] = {
                        x: firstPoint.x - lastSide * Math.cos(angleToFirst),
                        y: firstPoint.y - lastSide * Math.sin(angleToFirst)
                    };
                }
            }
            
            return coords;
        }

        function rotateCoordinates(coords) {
            return coords.map(coord => ({
                x: coord.y,
                y: -coord.x
            }));
        }

        function rotatePlot() {
            if (coordinates.length < 3) {
                document.getElementById('errorMessage').innerHTML = '<div class="error">No valid plot to rotate.</div>';
                return;
            }
            
            sideLengths = [sideLengths[sideLengths.length - 1], ...sideLengths.slice(0, -1)];
            for (let i = 1; i <= sideLengths.length; i++) {
                document.getElementById(`side${i}`).value = sideLengths[i - 1];
            }
            
            coordinates = rotateCoordinates(coordinates);
            rotationCount = (rotationCount + 1) % 4;
            updatePlot();
        }

        function calculateArea(coords) {
            if (coords.length < 3) return 0;
            let area = 0;
            const n = coords.length;
            for (let i = 0; i < n; i++) {
                const j = (i + 1) % n;
                area += coords[i].x * coords[j].y;
                area -= coords[j].x * coords[i].y;
            }
            return Math.abs(area) / 2;
        }

        function validatePolygonClosure(sides) {
            const numSides = sides.length;
            const totalLength = sides.reduce((sum, length) => sum + length, 0);
            const maxSide = Math.max(...sides);
            
            if (sides.some(side => side < 0.01 || side > 1000000)) return false;
            if (maxSide >= (totalLength - maxSide)) return false;
            
            for (let i = 0; i < numSides; i++) {
                const side = sides[i];
                const otherSidesSum = totalLength - side;
                if (side >= otherSidesSum) return false;
            }
            
            return true;
        }

        function calculateAndDraw() {
            const numSides = parseInt(document.getElementById('numSides').value);
            const unit = document.getElementById('unit').value;
            const errorDiv = document.getElementById('errorMessage');
            
            errorDiv.innerHTML = '';
            sideLengths = [];
            
            for (let i = 1; i <= numSides; i++) {
                const length = parseFloat(document.getElementById(`side${i}`).value);
                if (isNaN(length) || length <= 0) {
                    errorDiv.innerHTML = '<div class="error">Please fill in all side lengths with positive numbers.</div>';
                    return;
                }
                sideLengths.push(length);
            }
            
            if (sideLengths.length < 3) {
                errorDiv.innerHTML = '<div class="error">At least 3 sides are required.</div>';
                return;
            }
            
            if (!validatePolygonClosure(sideLengths)) {
                errorDiv.innerHTML = '<div class="error">These side lengths cannot form a closed polygon.</div>';
                return;
            }
            
            coordinates = constructPolygonFromSides(sideLengths);
            if (coordinates.length < 3) {
                errorDiv.innerHTML = '<div class="error">Could not construct a valid polygon.</div>';
                return;
            }
            
            const areaInUnits = calculateArea(coordinates);
            const unitFactor = unitFactors[unit];
            const areaInSquareMeters = areaInUnits * unitFactor * unitFactor;
            
            if (areaInUnits < 0.0001) {
                errorDiv.innerHTML = '<div class="warning">The calculated area is very small.</div>';
            }
            
            lastCalculatedResults = { areaInUnits, unit, areaInSquareMeters };
            divisions = [];
            divisionAreas = [];
            document.getElementById('divisionSection').style.display = 'block';
            document.getElementById('numParts').value = 2;
            document.getElementById('divisionType').value = 'equal';
            document.getElementById('divisionDirection').value = 'horizontal';
            generateDivisionInputs();
            
            drawPlot();
            displayResults(areaInUnits, unit, areaInSquareMeters);
        }

        function dividePlot() {
            const numParts = parseInt(document.getElementById('numParts').value);
            const divisionType = document.getElementById('divisionType').value;
            const divisionDirection = document.getElementById('divisionDirection').value;
            const errorDiv = document.getElementById('divisionError');
            errorDiv.innerHTML = '';
            
            if (!lastCalculatedResults) {
                errorDiv.innerHTML = '<div class="error">Please calculate the plot area first.</div>';
                return;
            }
            
            if (numParts < 2 || numParts > 10 || isNaN(numParts)) {
                errorDiv.innerHTML = '<div class="error">Please enter a number between 2 and 10 parts.</div>';
                return;
            }
            
            divisionAreas = [];
            let total = 0;
            if (divisionType === 'percentage') {
                for (let i = 1; i <= numParts; i++) {
                    const percentage = parseFloat(document.getElementById(`part${i}`).value);
                    if (isNaN(percentage) || percentage <= 0) {
                        errorDiv.innerHTML = '<div class="error">Please fill in all percentages with positive numbers.</div>';
                        return;
                    }
                    divisionAreas.push(percentage / 100 * lastCalculatedResults.areaInUnits);
                    total += percentage;
                }
                if (Math.abs(total - 100) > 0.01) {
                    errorDiv.innerHTML = '<div class="error">Percentages must sum to 100%.</div>';
                    return;
                }
            } else if (divisionType === 'area') {
                for (let i = 1; i <= numParts; i++) {
                    const area = parseFloat(document.getElementById(`part${i}`).value);
                    if (isNaN(area) || area <= 0) {
                        errorDiv.innerHTML = '<div class="error">Please fill in all areas with positive numbers.</div>';
                        return;
                    }
                    divisionAreas.push(area);
                    total += area;
                }
                if (Math.abs(total - lastCalculatedResults.areaInUnits) > 0.01) {
                    errorDiv.innerHTML = '<div class="error">Areas must sum to the total plot area.</div>';
                    return;
                }
            } else {
                divisionAreas = new Array(numParts).fill(lastCalculatedResults.areaInUnits / numParts);
            }
            
            divisions = calculateDivisions(divisionAreas, divisionDirection);
            drawPlot();
            displayResults(lastCalculatedResults.areaInUnits, lastCalculatedResults.unit, lastCalculatedResults.areaInSquareMeters);
        }

        function calculateDivisions(areas, direction) {
            const divisions = [];
            let accumulatedArea = 0;
            const totalArea = lastCalculatedResults.areaInUnits;
            
            // Find bounding box of the polygon
            const minX = Math.min(...coordinates.map(c => c.x));
            const maxX = Math.max(...coordinates.map(c => c.x));
            const minY = Math.min(...coordinates.map(c => c.y));
            const maxY = Math.max(...coordinates.map(c => c.y));
            
            // Calculate division points based on direction
            if (direction === 'horizontal') {
                // Divide along y-axis (horizontal lines)
                const height = maxY - minY;
                const areaPerUnitHeight = totalArea / height;
                let currentY = minY;
                
                for (let i = 0; i < areas.length - 1; i++) {
                    accumulatedArea += areas[i];
                    const targetArea = accumulatedArea;
                    const targetHeight = targetArea / areaPerUnitHeight;
                    currentY = minY + targetHeight;
                    
                    // Find intersection points with polygon edges
                    const intersections = findIntersectionsWithY(currentY);
                    if (intersections.length >= 2) {
                        // Sort intersections by x-coordinate
                        intersections.sort((a, b) => a.x - b.x);
                        divisions.push({
                            start: intersections[0],
                            end: intersections[intersections.length - 1]
                        });
                    }
                }
            } else {
                // Divide along x-axis (vertical lines)
                const width = maxX - minX;
                const areaPerUnitWidth = totalArea / width;
                let currentX = minX;
                
                for (let i = 0; i < areas.length - 1; i++) {
                    accumulatedArea += areas[i];
                    const targetArea = accumulatedArea;
                    const targetWidth = targetArea / areaPerUnitWidth;
                    currentX = minX + targetWidth;
                    
                    // Find intersection points with polygon edges
                    const intersections = findIntersectionsWithX(currentX);
                    if (intersections.length >= 2) {
                        // Sort intersections by y-coordinate
                        intersections.sort((a, b) => a.y - b.y);
                        divisions.push({
                            start: intersections[0],
                            end: intersections[intersections.length - 1]
                        });
                    }
                }
            }
            
            return divisions;
        }

        function findIntersectionsWithY(y) {
            const intersections = [];
            for (let i = 0; i < coordinates.length; i++) {
                const p1 = coordinates[i];
                const p2 = coordinates[(i + 1) % coordinates.length];
                const minY = Math.min(p1.y, p2.y);
                const maxY = Math.max(p1.y, p2.y);
                
                if (y > minY && y <= maxY) {
                    const x = p1.x + (y - p1.y) * (p2.x - p1.x) / (p2.y - p1.y);
                    intersections.push({ x, y });
                }
            }
            return intersections;
        }

        function findIntersectionsWithX(x) {
            const intersections = [];
            for (let i = 0; i < coordinates.length; i++) {
                const p1 = coordinates[i];
                const p2 = coordinates[(i + 1) % coordinates.length];
                const minX = Math.min(p1.x, p2.x);
                const maxX = Math.max(p1.x, p2.x);
                
                if (x > minX && x <= maxX) {
                    const y = p1.y + (x - p1.x) * (p2.y - p1.y) / (p2.x - p1.x);
                    intersections.push({ x, y });
                }
            }
            return intersections;
        }

        function updatePlot() {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.innerHTML = '';
            
            if (sideLengths.some(length => length <= 0 || isNaN(length))) {
                return;
            }
            
            if (!validatePolygonClosure(sideLengths)) {
                errorDiv.innerHTML = '<div class="error">These side lengths cannot form a closed polygon.</div>';
                return;
            }
            
            coordinates = constructPolygonFromSides(sideLengths);
            if (coordinates.length < 3) {
                errorDiv.innerHTML = '<div class="error">Could not construct a valid polygon.</div>';
                return;
            }
            
            const unit = document.getElementById('unit').value;
            const areaInUnits = calculateArea(coordinates);
            const unitFactor = unitFactors[unit];
            const areaInSquareMeters = areaInUnits * unitFactor * unitFactor;
            
            lastCalculatedResults = { areaInUnits, unit, areaInSquareMeters };
            divisions = [];
            divisionAreas = [];
            document.getElementById('divisionSection').style.display = 'block';
            generateDivisionInputs();
            
            drawPlot();
            displayResults(areaInUnits, unit, areaInSquareMeters);
        }

        function drawPlot() {
            if (!ctx) return;
            clearCanvas(false);
            
            if (coordinates.length < 3) return;
            
            const minX = Math.min(...coordinates.map(c => c.x));
            const maxX = Math.max(...coordinates.map(c => c.x));
            const minY = Math.min(...coordinates.map(c => c.y));
            const maxY = Math.max(...coordinates.map(c => c.y));
            
            const width = maxX - minX || 1;
            const height = maxY - minY || 1;
            const padding = 20;
            const scaleX = (canvas.width - 2 * padding) / width;
            const scaleY = (canvas.height - 2 * padding) / height;
            scale = Math.min(scaleX, scaleY, 50);
            
            offsetX = (canvas.width - width * scale) / 2 - minX * scale;
            offsetY = (canvas.height - height * scale) / 2 - minY * scale;
            
            drawGrid();
            
            ctx.beginPath();
            ctx.strokeStyle = '#4facfe';
            ctx.fillStyle = 'rgba(79, 172, 254, 0.2)';
            ctx.lineWidth = 3;
            coordinates.forEach((coord, index) => {
                const x = coord.x * scale + offsetX;
                const y = canvas.height - (coord.y * scale + offsetY);
                if (index === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            coordinates.forEach((coord, index) => {
                const x = coord.x * scale + offsetX;
                const y = canvas.height - (coord.y * scale + offsetY);
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, 2 * Math.PI);
                ctx.fillStyle = '#dc2626';
                ctx.fill();
                ctx.fillStyle = '#374151';
                ctx.font = 'bold 10px Arial';
                ctx.fillText(`P${index + 1}`, x + 8, y - 8);
            });
            
            for (let i = 0; i < coordinates.length; i++) {
                const current = coordinates[i];
                const next = coordinates[(i + 1) % coordinates.length];
                const sideLength = sideLengths[i];
                const x1 = current.x * scale + offsetX;
                const y1 = canvas.height - (current.y * scale + offsetY);
                const x2 = next.x * scale + offsetX;
                const y2 = canvas.height - (next.y * scale + offsetY);
                const midX = (x1 + x2) / 2;
                const midY = (y1 + y2) / 2;
                const rectWidth = Math.max(30, 30 * scale / 50);
                const rectHeight = Math.max(20, 20 * scale / 50);
                
                ctx.fillStyle = i === selectedSideIndex ? 'rgba(255, 255, 0, 0.5)' : 'rgba(255, 255, 255, 0.9)';
                ctx.fillRect(midX - rectWidth / 2, midY - rectHeight / 2, rectWidth, rectHeight);
                ctx.fillStyle = '#059669';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`S${i + 1}: ${sideLength.toFixed(2)}`, midX, midY + 3);
                ctx.textAlign = 'left';
            }
            
            // Draw division lines
            if (divisions.length > 0) {
                divisions.forEach((division, index) => {
                    ctx.beginPath();
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    const x1 = division.start.x * scale + offsetX;
                    const y1 = canvas.height - (division.start.y * scale + offsetY);
                    const x2 = division.end.x * scale + offsetX;
                    const y2 = canvas.height - (division.end.y * scale + offsetY);
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    const midX = (x1 + x2) / 2;
                    const midY = (y1 + y2) / 2;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.fillRect(midX - 20, midY - 10, 40, 20);
                    ctx.fillStyle = '#ff0000';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`D${index + 1}`, midX, midY + 3);
                    ctx.textAlign = 'left';
                });
            }
        }

        function drawGrid() {
            if (!ctx) return;
            ctx.strokeStyle = '#e5e7eb';
            ctx.lineWidth = 1;
            const gridSpacing = Math.max(10, 20 / scale);
            for (let x = 0; x <= canvas.width; x += gridSpacing * scale) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= canvas.height; y += gridSpacing * scale) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        function handleCanvasClick(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            for (let i = 0; i < coordinates.length; i++) {
                const current = coordinates[i];
                const next = coordinates[(i + 1) % coordinates.length];
                const x1 = current.x * scale + offsetX;
                const y1 = canvas.height - (current.y * scale + offsetY);
                const x2 = next.x * scale + offsetX;
                const y2 = canvas.height - (next.y * scale + offsetY);
                const midX = (x1 + x2) / 2;
                const midY = (y1 + y2) / 2;
                const rectWidth = Math.max(30, 30 * scale / 50);
                const rectHeight = Math.max(20, 20 * scale / 50);
                
                if (x >= midX - rectWidth / 2 && x <= midX + rectWidth / 2 && 
                    y >= midY - rectHeight / 2 && y <= midY + rectHeight / 2) {
                    selectedSideIndex = i;
                    const newLength = prompt(`Enter length for Side ${i + 1} (S${i + 1}):`, sideLengths[i]);
                    if (newLength !== null) {
                        const parsedLength = parseFloat(newLength);
                        if (!isNaN(parsedLength) && parsedLength > 0) {
                            sideLengths[i] = parsedLength;
                            document.getElementById(`side${i + 1}`).value = parsedLength;
                            updatePlot();
                        } else {
                            alert('Please enter a valid positive number.');
                        }
                    }
                    drawPlot();
                    break;
                }
            }
        }

        function displayResults(areaInUnits, unit, areaInSquareMeters) {
            const resultsDiv = document.getElementById('results');
            let conversionsHTML = '';
            for (const [convertUnit, factor] of Object.entries(areaConversions)) {
                const convertedArea = areaInSquareMeters * factor;
                conversionsHTML += `
                    <div class="unit-conversion">
                        <strong>${convertedArea.toFixed(4)}</strong><br>
                        ${convertUnit}
                    </div>
                `;
            }
            
            const totalPerimeter = sideLengths.reduce((sum, length) => sum + length, 0);
            let divisionHTML = '';
            if (divisions.length > 0) {
                const divisionType = document.getElementById('divisionType').value;
                const divisionDirection = document.getElementById('divisionDirection').value;
                divisionHTML = `<h3>üß© Divided Areas (${divisionDirection})</h3>`;
                divisionAreas.forEach((area, index) => {
                    let label = `Part ${index + 1}: ${area.toFixed(4)} sq ${unit}`;
                    if (divisionType === 'percentage') {
                        const percentage = (area / areaInUnits * 100).toFixed(2);
                        label += ` (${percentage}%)`;
                    }
                    divisionHTML += `<p><strong>${label}</strong></p>`;
                });
            }
            
            resultsDiv.innerHTML = `
                <div class="results">
                    <h3>üìä Calculated Areas</h3>
                    <div class="area-display">${areaInUnits.toFixed(4)} sq ${unit}</div>
                    <p><strong>Perimeter:</strong> ${totalPerimeter.toFixed(2)} ${unit}</p>
                    <div class="unit-conversions">
                        ${conversionsHTML}
                    </div>
                    ${divisionHTML}
                </div>
            `;
            resultsDiv.style.display = 'block';
        }

        function clearCanvas(hideResults = true) {
            if (!ctx) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#fafafa';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (hideResults) {
                document.getElementById('results').style.display = 'none';
                document.getElementById('divisionSection').style.display = 'none';
                lastCalculatedResults = null;
                sideLengths = [];
                coordinates = [];
                divisions = [];
                divisionAreas = [];
                selectedSideIndex = -1;
                rotationCount = 0;
            } else if (lastCalculatedResults) {
                displayResults(
                    lastCalculatedResults.areaInUnits,
                    lastCalculatedResults.unit,
                    lastCalculatedResults.areaInSquareMeters
                );
            }
        }

        function downloadCanvas() {
            if (!ctx) return;
            ctx.save();
            ctx.font = '6.5px Arial';
            ctx.fillStyle = '#374151';
            ctx.textAlign = 'right';
            ctx.fillText('Created by Ved Mangukiya, Founder of ProjectUnifyX | Generated using our Custom Plot Area Finder - Free professional surveying tools at unifyxproject.netlify.app', canvas.width - 8, canvas.height - 8);
            
            const link = document.createElement('a');
            link.download = 'plot-area-calculation.png';
            link.href = canvas.toDataURL();
            link.click();
            
            ctx.restore();
            drawPlot();
        }

        function downloadResultsAsPDF() {
            if (!window.jspdf) {
                document.getElementById('errorMessage').innerHTML = '<div class="error">PDF library not loaded.</div>';
                return;
            }
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({
                orientation: 'portrait',
                unit: 'mm',
                format: 'a4'
            });

            doc.setFillColor(79, 172, 254);
            doc.rect(0, 0, 210, 30, 'F');
            doc.setFontSize(18);
            doc.setTextColor(255, 255, 255);
            doc.setFont('helvetica', 'bold');
            doc.text('Custom Plot Area Finder', 10, 15);
            doc.setFontSize(12);
            doc.setFont('helvetica', 'normal');
            doc.text('Area Calculation Report', 10, 25);

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width * 2;
            tempCanvas.height = canvas.height * 2;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.scale(2, 2);
            tempCtx.translate(canvas.width / 2, canvas.height / 2);
            tempCtx.rotate(rotationCount * Math.PI / 2);
            tempCtx.translate(-canvas.width / 2, -canvas.height / 2);
            
            tempCtx.fillStyle = '#fafafa';
            tempCtx.fillRect(0, 0, canvas.width, canvas.height);
            drawGridOnCanvas(tempCtx);
            
            tempCtx.beginPath();
            tempCtx.strokeStyle = '#4facfe';
            tempCtx.fillStyle = 'rgba(79, 172, 254, 0.2)';
            tempCtx.lineWidth = 3;
            coordinates.forEach((coord, index) => {
                const x = coord.x * scale + offsetX;
                const y = canvas.height - (coord.y * scale + offsetY);
                if (index === 0) tempCtx.moveTo(x, y);
                else tempCtx.lineTo(x, y);
            });
            tempCtx.closePath();
            tempCtx.fill();
            tempCtx.stroke();
            
            coordinates.forEach((coord, index) => {
                const x = coord.x * scale + offsetX;
                const y = canvas.height - (coord.y * scale + offsetY);
                tempCtx.beginPath();
                tempCtx.arc(x, y, 4, 0, 2 * Math.PI);
                tempCtx.fillStyle = '#dc2626';
                tempCtx.fill();
                tempCtx.fillStyle = '#374151';
                tempCtx.font = 'bold 10px Arial';
                tempCtx.fillText(`P${index + 1}`, x + 8, y - 8);
            });
            
            for (let i = 0; i < coordinates.length; i++) {
                const current = coordinates[i];
                const next = coordinates[(i + 1) % coordinates.length];
                const sideLength = sideLengths[i];
                const x1 = current.x * scale + offsetX;
                const y1 = canvas.height - (current.y * scale + offsetY);
                const x2 = next.x * scale + offsetX;
                const y2 = canvas.height - (next.y * scale + offsetY);
                const midX = (x1 + x2) / 2;
                const midY = (y1 + y2) / 2;
                const rectWidth = Math.max(30, 30 * scale / 50);
                const rectHeight = Math.max(20, 20 * scale / 50);
                tempCtx.fillStyle = i === selectedSideIndex ? 'rgba(255, 255, 0, 0.5)' : 'rgba(255, 255, 255, 0.9)';
                tempCtx.fillRect(midX - rectWidth / 2, midY - rectHeight / 2, rectWidth, rectHeight);
                tempCtx.fillStyle = '#059669';
                tempCtx.font = 'bold 10px Arial';
                tempCtx.textAlign = 'center';
                tempCtx.fillText(`S${i + 1}: ${sideLength.toFixed(2)}`, midX, midY + 3);
                tempCtx.textAlign = 'left';
            }
            
            if (divisions.length > 0) {
                divisions.forEach((division, index) => {
                    tempCtx.beginPath();
                    tempCtx.strokeStyle = '#ff0000';
                    tempCtx.lineWidth = 2;
                    tempCtx.setLineDash([5, 5]);
                    const x1 = division.start.x * scale + offsetX;
                    const y1 = canvas.height - (division.start.y * scale + offsetY);
                    const x2 = division.end.x * scale + offsetX;
                    const y2 = canvas.height - (division.end.y * scale + offsetY);
                    tempCtx.moveTo(x1, y1);
                    tempCtx.lineTo(x2, y2);
                    tempCtx.stroke();
                    tempCtx.setLineDash([]);
                    
                    const midX = (x1 + x2) / 2;
                    const midY = (y1 + y2) / 2;
                    tempCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    tempCtx.fillRect(midX - 20, midY - 10, 40, 20);
                    tempCtx.fillStyle = '#ff0000';
                    tempCtx.font = 'bold 10px Arial';
                    tempCtx.textAlign = 'center';
                    tempCtx.fillText(`D${index + 1}`, midX, midY + 3);
                    tempCtx.textAlign = 'left';
                });
            }
            
            tempCtx.font = '6.5px Arial';
            tempCtx.fillStyle = '#374151';
            tempCtx.textAlign = 'right';
            tempCtx.fillText('Created by Ved Mangukiya, Founder of ProjectUnifyX | Generated using our Custom Plot Area Finder - Free professional surveying tools at unifyxproject.netlify.app', canvas.width - 8, canvas.height - 8);
            
            const imgData = tempCanvas.toDataURL('image/png', 1.0);
            doc.addImage(imgData, 'PNG', 10, 35, 190, 152);
            
            if (lastCalculatedResults) {
                const { areaInUnits, unit, areaInSquareMeters } = lastCalculatedResults;
                const totalPerimeter = sideLengths.reduce((sum, length) => sum + length, 0);

                doc.setFillColor(240, 249, 255);
                doc.rect(10, 195, 190, divisions.length > 0 ? 100 : 85, 'F');
                doc.setDrawColor(79, 172, 254);
                doc.setLineWidth(0.5);
                doc.rect(10, 195, 190, divisions.length > 0 ? 100 : 85);

                doc.setFontSize(14);
                doc.setTextColor(55, 65, 81);
                doc.setFont('helvetica', 'bold');
                doc.text('Calculated Results', 15, 205);

                doc.setFontSize(12);
                doc.setTextColor(0, 0, 0);
                doc.text(`Area: ${areaInUnits.toFixed(4)} square ${unit}`, 15, 215);
                doc.text(`Perimeter: ${totalPerimeter.toFixed(2)} ${unit}`, 15, 225);

                let yOffset = 235;
                doc.setFontSize(10);
                for (const [convertUnit, factor] of Object.entries(areaConversions)) {
                    if (yOffset >= 270) break;
                    const convertedArea = areaInSquareMeters * factor;
                    doc.setFillColor(255, 255, 255);
                    doc.roundedRect(15, yOffset - 4, 80, 10, 2, 2, 'F');
                    doc.setTextColor(0, 0, 0);
                    doc.text(`${convertedArea.toFixed(4)} ${convertUnit}`, 20, yOffset + 4);
                    yOffset += 12;
                }

                if (divisions.length > 0) {
                    doc.setFontSize(12);
                    doc.setTextColor(55, 65, 81);
                    const divisionDirection = document.getElementById('divisionDirection').value;
                    doc.text(`Divided Areas (${divisionDirection})`, 15, yOffset);
                    yOffset += 10;
                    doc.setFontSize(10);
                    const divisionType = document.getElementById('divisionType').value;
                    divisionAreas.forEach((area, index) => {
                        let label = `Part ${index + 1}: ${area.toFixed(4)} sq ${unit}`;
                        if (divisionType === 'percentage') {
                            const percentage = (area / areaInUnits * 100).toFixed(2);
                            label += ` (${percentage}%)`;
                        }
                        doc.text(label, 20, yOffset + 4);
                        yOffset += 10;
                    });
                }
            } else {
                doc.setFontSize(12);
                doc.setTextColor(220, 38, 38);
                doc.text('No results available.', 10, 195);
            }

            doc.setFontSize(7.5);
            doc.setTextColor(55, 65, 81);
            doc.setFont('helvetica', 'normal');
            doc.text('Created by Ved Mangukiya, Founder of ProjectUnifyX | Generated using our Custom Plot Area Finder - Free professional surveying tools at unifyxproject.netlify.app', 10, 290);

            doc.save('plot-with-areas.pdf');
        }

        function drawGridOnCanvas(context) {
            context.strokeStyle = '#e5e7eb';
            context.lineWidth = 1;
            const gridSpacing = Math.max(10, 20 / scale);
            for (let x = 0; x <= canvas.width; x += gridSpacing * scale) {
                context.beginPath();
                context.moveTo(x, 0);
                context.lineTo(x, canvas.height);
                context.stroke();
            }
            for (let y = 0; y <= canvas.height; y += gridSpacing * scale) {
                context.beginPath();
                context.moveTo(0, y);
                context.lineTo(canvas.width, y);
                context.stroke();
            }
        }

        function showGuide() {
            document.getElementById('guideModal').style.display = 'flex';
        }

        function closeGuide() {
            document.getElementById('guideModal').style.display = 'none';
        }

        window.onload = function() {
            initCanvas();
            generateSideInputs();
            document.getElementById('current-year').textContent = new Date().getFullYear();
            document.getElementById('divisionType').addEventListener('change', generateDivisionInputs);
            window.addEventListener('resize', () => {
                initCanvas();
                if (coordinates.length > 0) drawPlot();
            });
        };
    </script>
</body>
</html>