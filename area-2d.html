<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üßÆ PlotMaster - Area Calculator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        :root {
            --primary-color: #3b82f6;
            --secondary-color: #1f2937;
            --background-color: #f3f4f6;
            --white: #ffffff;
            --error-color: #dc2626;
            --success-color: #059669;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--background-color);
            min-height: 100vh;
        }

        .app-container {
            display: flex;
            min-height: 100vh;
        }

        .sidebar {
            width: 240px;
            background: var(--secondary-color);
            color: var(--white);
            padding: 20px;
            position: fixed;
            height: 100%;
            transition: transform 0.3s ease;
        }

        .sidebar.hidden {
            transform: translateX(-240px);
        }

        .sidebar-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 24px;
        }

        .sidebar-header h1 {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .nav-item {
            padding: 10px 12px;
            margin: 4px 0;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.2s ease;
        }

        .nav-item:hover {
            background: #374151;
        }

        .nav-item.active {
            background: var(--primary-color);
        }

        .main-content {
            flex: 1;
            margin-left: 240px;
            padding: 20px;
            transition: margin-left 0.3s ease;
        }

        .main-content.full {
            margin-left: 0;
        }

        .header {
            background: var(--primary-color);
            color: var(--white);
            padding: 12px 16px;
            border-radius: 6px;
            margin-bottom: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .toggle-sidebar {
            background: var(--white);
            color: var(--primary-color);
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
        }

        .page {
            display: none;
            background: var(--white);
            border-radius: 8px;
            padding: 16px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .page.active {
            display: block;
        }

        .section {
            margin-bottom: 16px;
            padding: 12px;
            background: #f9fafb;
            border-radius: 6px;
        }

        .section-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--secondary-color);
            margin-bottom: 12px;
        }

        .form-group {
            margin-bottom: 12px;
        }

        label {
            display: block;
            font-weight: 500;
            color: #374151;
            margin-bottom: 4px;
        }

        input, select {
            width: 100%;
            padding: 8px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 0.9rem;
            background: var(--white);
            transition: border-color 0.2s ease;
        }

        input:focus, select:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
            outline: none;
        }

        .sides-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 8px;
        }

        .btn {
            background: var(--primary-color);
            color: var(--white);
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .btn:hover {
            background: #2563eb;
        }

        #canvas {
            border: 1px solid #d1d5db;
            border-radius: 6px;
            background: var(--white);
            width: 100%;
            max-width: 600px;
            height: 400px;
            margin: 0 auto;
            cursor: crosshair;
        }

        .canvas-controls {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }

        .results {
            background: #e5e7eb;
            padding: 12px;
            border-radius: 6px;
            margin-top: 12px;
        }

        .history-item {
            background: #f3f4f6;
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .history-item:hover {
            background: #e5e7eb;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-content {
            background: var(--white);
            padding: 16px;
            border-radius: 8px;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .close-btn {
            background: #ef4444;
            color: var(--white);
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            float: right;
        }

        .error {
            background: #fee2e2;
            color: var(--error-color);
            padding: 8px;
            border-radius: 4px;
            margin-top: 8px;
        }

        @media (max-width: 768px) {
            .sidebar {
                transform: translateX(-240px);
            }

            .sidebar.active {
                transform: translateX(0);
            }

            .main-content {
                margin-left: 0;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <span>üßÆ</span>
                <h1>PlotMaster</h1>
            </div>
            <div class="nav-item" data-page="home">üè† Home</div>
            <div class="nav-item" data-page="editor">üìê Plot Editor</div>
            <div class="nav-item" data-page="results">üìä Results</div>
            <div class="nav-item" data-page="history">üìú History</div>
            <div class="nav-item" onclick="showGuide()">‚ÑπÔ∏è Guide</div>
        </div>

        <div class="main-content" id="mainContent">
            <div class="header">
                <h1 id="pageTitle">Welcome to PlotMaster</h1>
                <button class="toggle-sidebar" onclick="toggleSidebar()">‚ò∞ Menu</button>
            </div>

            <div class="page active" id="home">
                <div class="section">
                    <h2 class="section-title">Welcome to PlotMaster</h2>
                    <p>Calculate and visualize land plot areas with ease.</p>
                    <ul>
                        <li>Supports 3-8 sided polygons</li>
                        <li>Divide plots into equal or custom areas</li>
                        <li>Interactive canvas with zoom and pan</li>
                        <li>Save/load configurations</li>
                        <li>Export as PNG or PDF</li>
                        <li>View calculation history</li>
                    </ul>
                    <button class="btn" onclick="navigateTo('editor')">Start Plotting</button>
                </div>
            </div>

            <div class="page" id="editor">
                <div class="section">
                    <h2 class="section-title">Plot Configuration</h2>
                    <div class="form-group">
                        <label for="numSides">Number of Sides (3-8)</label>
                        <input type="number" id="numSides" min="3" max="8" value="4">
                    </div>
                    <div class="form-group">
                        <label for="unit">Unit</label>
                        <select id="unit">
                            <option value="meters">Meters</option>
                            <option value="feet">Feet</option>
                            <option value="yards">Yards</option>
                            <option value="inches">Inches</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <button class="btn" onclick="generateSideInputs()">Generate Sides</button>
                        <button class="btn" onclick="importConfig()">Import Config</button>
                        <input type="file" id="importFile" style="display: none;" accept=".json">
                    </div>
                    <div id="sideInputs" class="sides-grid"></div>
                    <div id="errorMessage"></div>
                    <div class="form-group">
                        <button class="btn" onclick="calculateAndDraw()">Calculate & Draw</button>
                        <button class="btn" onclick="saveConfig()">Save Config</button>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-title">Plot Visualization</h2>
                    <div class="canvas-controls">
                        <button class="btn" onclick="clearCanvas()">Clear</button>
                        <button class="btn" onclick="rotatePlot()">Rotate</button>
                        <button class="btn" onclick="zoomIn()">Zoom In</button>
                        <button class="btn" onclick="zoomOut()">Zoom Out</button>
                        <button class="btn" onclick="downloadCanvas()">Download PNG</button>
                        <button class="btn" onclick="downloadResultsAsPDF()">Download PDF</button>
                    </div>
                    <canvas id="canvas"></canvas>
                </div>

                <div class="section" id="divisionSection" style="display: none;">
                    <h2 class="section-title">Divide Plot</h2>
                    <div class="form-group">
                        <div class="sides-grid">
                            <div>
                                <label for="numPCS">Number of Parts (2-10)</label>
                                <input type="number" id="numParts" min="2" max="10" value="2">
                            </div>
                            <div>
                                <label for="divisionType">Division Type</label>
                                <select id="divisionType">
                                    <option value="equal">Equal Area</option>
                                    <option value="percentage">Percentage-Wise</option>
                                    <option value="area">Area-Wise</option>
                                </select>
                            </div>
                            <div>
                                <label for="divisionDirection">Division Direction</label>
                                <select id="divisionDirection">
                                    <option value="horizontal">Horizontal</option>
                                    <option value="vertical">Vertical</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    <div id="divisionInputs" class="sides-grid"></div>
                    <div id="divisionError"></div>
                    <button class="btn" onclick="dividePlot()">Divide Plot</button>
                </div>
            </div>

            <div class="page" id="results">
                <div class="section">
                    <h2 class="section-title">Results</h2>
                    <div id="resultsDisplay"></div>
                </div>
            </div>

            <div class="page" id="history">
                <div class="section">
                    <h2 class="section-title">Calculation History</h2>
                    <div id="historyList"></div>
                    <button class="btn" onclick="clearHistory()">Clear History</button>
                </div>
            </div>
        </div>
    </div>

    <div id="guideModal" class="modal">
        <div class="modal-content">
            <button class="close-btn" onclick="closeGuide()">Close</button>
            <h2>PlotMaster Guide</h2>
            <p>Use PlotMaster to calculate and visualize land plots:</p>
            <ul>
                <li><strong>Home:</strong> Start here for an overview.</li>
                <li><strong>Plot Editor:</strong> Create and visualize plots:
                    <ul>
                        <li>Set number of sides (3-8) and unit.</li>
                        <li>Enter side lengths.</li>
                        <li>Calculate area and draw plot.</li>
                        <li>Divide plot into parts.</li>
                        <li>Use canvas controls for zoom, pan, rotate, or export.</li>
                    </ul>
                </li>
                <li><strong>Results:</strong> View area calculations.</li>
                <li><strong>History:</strong> Review and reload past calculations.</li>
            </ul>
            <p><strong>Tip:</strong> Save configurations as JSON for reuse.</p>
        </div>
    </div>

    <script>
        // State Management
        let state = {
            canvas: null,
            ctx: null,
            coordinates: [],
            sideLengths: [],
            scale: 1,
            offsetX: 0,
            offsetY: 0,
            lastCalculatedResults: null,
            selectedSideIndex: -1,
            updateTimeout: null,
            rotationCount: 0,
            divisions: [],
            divisionAreas: [],
            zoomLevel: 1,
            panX: 0,
            panY: 0,
            isPanning: false,
            history: JSON.parse(localStorage.getItem('plotHistory')) || []
        };

        const unitFactors = {
            meters: 1,
            feet: 0.3048,
            yards: 0.9144,
            inches: 0.0254
        };

        const areaConversions = {
            'square meters': 1,
            'square feet': 10.764,
            'square yards': 1.196,
            'acres': 0.000247,
            'hectares': 0.0001
        };

        // Canvas Initialization
        function initCanvas() {
            state.canvas = document.getElementById('canvas');
            state.canvas.width = Math.min(window.innerWidth - 40, 600);
            state.canvas.height = 400;
            state.ctx = state.canvas.getContext('2d');
            if (!state.ctx) {
                showError('Canvas initialization failed.');
                return;
            }
            clearCanvas();
            state.canvas.addEventListener('click', handleCanvasClick);
            state.canvas.addEventListener('mousedown', startPan);
            state.canvas.addEventListener('mousemove', pan);
            state.canvas.addEventListener('mouseup', endPan);
            state.canvas.addEventListener('mouseleave', endPan);
        }

        // UI Interactions
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const mainContent = document.getElementById('mainContent');
            sidebar.classList.toggle('hidden');
            mainContent.classList.toggle('full');
        }

        function navigateTo(pageId) {
            document.querySelectorAll('.page').forEach(page => page.classList.remove('active'));
            document.querySelectorAll('.nav-item').forEach(item => item.classList.remove('active'));
            document.getElementById(pageId).classList.add('active');
            document.querySelector(`.nav-item[data-page="${pageId}"]`).classList.add('active');
            document.getElementById('pageTitle').textContent = {
                home: 'Welcome to PlotMaster',
                editor: 'Plot Editor',
                results: 'Results',
                history: 'Calculation History'
            }[pageId];
            if (pageId === 'results' && state.lastCalculatedResults) {
                displayResults(state.lastCalculatedResults.areaInUnits, state.lastCalculatedResults.unit, state.lastCalculatedResults.areaInSquareMeters);
            }
            if (pageId === 'history') {
                displayHistory();
            }
            toggleSidebar();
        }

        function showGuide() {
            document.getElementById('guideModal').style.display = 'flex';
        }

        function closeGuide() {
            document.getElementById('guideModal').style.display = 'none';
        }

        // Plot Configuration
        function generateSideInputs() {
            const numSides = parseInt(document.getElementById('numSides').value);
            const container = document.getElementById('sideInputs');
            const errorDiv = document.getElementById('errorMessage');

            errorDiv.innerHTML = '';
            document.getElementById('divisionSection').style.display = 'none';
            state.divisions = [];
            state.divisionAreas = [];

            if (numSides < 3 || numSides > 8 || isNaN(numSides)) {
                showError('Please enter a number between 3 and 8 sides.');
                return;
            }

            container.innerHTML = '';
            state.sideLengths = new Array(numSides).fill(100);

            for (let i = 1; i <= numSides; i++) {
                const sideGroup = document.createElement('div');
                sideGroup.className = 'side-group';
                sideGroup.innerHTML = `
                    <label>Side ${i}</label>
                    <input type="number" id="side${i}" step="0.01" min="0.1" value="100">
                `;
                container.appendChild(sideGroup);
                document.getElementById(`side${i}`).addEventListener('input', () => {
                    state.sideLengths[i-1] = parseFloat(document.getElementById(`side${i}`).value) || 0;
                    saveState();
                    debounceUpdatePlot();
                });
            }
            saveState();
        }

        function generateDivisionInputs() {
            const numParts = parseInt(document.getElementById('numParts').value);
            const divisionType = document.getElementById('divisionType').value;
            const container = document.getElementById('divisionInputs');
            const errorDiv = document.getElementById('divisionError');
            const unit = document.getElementById('unit').value;

            errorDiv.innerHTML = '';

            if (numParts < 2 || numParts > 10 || isNaN(numParts)) {
                showError('Please enter a number between 2 and 10 parts.', 'divisionError');
                return;
            }

            container.innerHTML = '';
            state.divisionAreas = new Array(numParts).fill(0);

            for (let i = 1; i <= numParts; i++) {
                const divGroup = document.createElement('div');
                divGroup.className = 'side-group';
                let inputHTML = '';
                if (divisionType === 'percentage') {
                    inputHTML = `
                        <label>Part ${i} Percentage</label>
                        <input type="number" id="part${i}" step="0.01" min="0.1" value="${(100/numParts).toFixed(2)}">
                    `;
                } else if (divisionType === 'area') {
                    inputHTML = `
                        <label>Part ${i} Area (sq ${unit})</label>
                        <input type="number" id="part${i}" step="0.01" min="0.1" value="${(state.lastCalculatedResults.areaInUnits/numParts).toFixed(2)}">
                    `;
                } else {
                    return;
                }
                divGroup.innerHTML = inputHTML;
                container.appendChild(divGroup);
                document.getElementById(`part${i}`).addEventListener('input', () => {
                    state.divisionAreas[i-1] = parseFloat(document.getElementById(`part${i}`).value) || 0;
                    saveState();
                    debounceDividePlot();
                });
            }
            saveState();
        }

        // State Persistence
        function saveState() {
            const currentState = {
                numSides: document.getElementById('numSides').value,
                unit: document.getElementById('unit').value,
                sideLengths: state.sideLengths,
                numParts: document.getElementById('numParts').value,
                divisionType: document.getElementById('divisionType').value,
                divisionDirection: document.getElementById('divisionDirection').value,
                divisionAreas: state.divisionAreas
            };
            localStorage.setItem('plotState', JSON.stringify(currentState));
        }

        function loadState() {
            const savedState = JSON.parse(localStorage.getItem('plotState'));
            if (savedState) {
                document.getElementById('numSides').value = savedState.numSides;
                document.getElementById('unit').value = savedState.unit;
                document.getElementById('numParts').value = savedState.numParts;
                document.getElementById('divisionType').value = savedState.divisionType;
                document.getElementById('divisionDirection').value = savedState.divisionDirection;
                state.sideLengths = savedState.sideLengths || [];
                state.divisionAreas = savedState.divisionAreas || [];
                generateSideInputs();
                if (state.sideLengths.length > 0) {
                    for (let i = 1; i <= state.sideLengths.length; i++) {
                        document.getElementById(`side${i}`).value = state.sideLengths[i-1];
                    }
                    calculateAndDraw();
                    generateDivisionInputs();
                    for (let i = 1; i <= state.divisionAreas.length; i++) {
                        const input = document.getElementById(`part${i}`);
                        if (input) input.value = state.divisionAreas[i-1];
                    }
                }
            }
        }

        // Configuration Management
        function saveConfig() {
            const config = {
                numSides: parseInt(document.getElementById('numSides').value),
                unit: document.getElementById('unit').value,
                sideLengths: state.sideLengths,
                numParts: state.divisions.length > 0 ? parseInt(document.getElementById('numParts').value) : null,
                divisionType: state.divisions.length > 0 ? document.getElementById('divisionType').value : null,
                divisionDirection: state.divisions.length > 0 ? document.getElementById('divisionDirection').value : null,
                divisionAreas: state.divisionAreas
            };
            const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'plot-config.json';
            link.click();
        }

        function importConfig() {
            document.getElementById('importFile').click();
        }

        document.getElementById('importFile').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const config = JSON.parse(e.target.result);
                        document.getElementById('numSides').value = config.numSides;
                        document.getElementById('unit').value = config.unit;
                        state.sideLengths = config.sideLengths;
                        generateSideInputs();
                        for (let i = 1; i <= state.sideLengths.length; i++) {
                            document.getElementById(`side${i}`).value = state.sideLengths[i-1];
                        }
                        calculateAndDraw();
                        if (config.numParts) {
                            document.getElementById('numParts').value = config.numParts;
                            document.getElementById('divisionType').value = config.divisionType;
                            document.getElementById('divisionDirection').value = config.divisionDirection;
                            state.divisionAreas = config.divisionAreas;
                            generateDivisionInputs();
                            for (let i = 1; i <= state.divisionAreas.length; i++) {
                                document.getElementById(`part${i}`).value = state.divisionAreas[i-1];
                            }
                            dividePlot();
                        }
                    } catch (err) {
                        showError('Invalid configuration file.');
                    }
                };
                reader.readAsText(file);
            }
        });

        // Plot Calculations
        function constructPolygonFromSides(sides) {
            const numSides = sides.length;
            if (numSides < 3) return [];
            const coords = [{ x: 0, y: 0 }];
            let currentAngle = 0;
            for (let i = 0; i < numSides; i++) {
                const lastPoint = coords[coords.length - 1];
                const sideLength = sides[i];
                const angleStep = (2 * Math.PI) / numSides;
                currentAngle += angleStep;
                const newX = lastPoint.x + sideLength * Math.cos(currentAngle);
                const newY = lastPoint.y + sideLength * Math.sin(currentAngle);
                coords.push({ x: newX, y: newY });
            }
            if (coords.length === numSides + 1) {
                coords.pop();
            }
            return coords;
        }

        function calculateArea(coords) {
            if (coords.length < 3) return 0;
            let area = 0;
            const n = coords.length;
            for (let i = 0; i < n; i++) {
                const j = (i + 1) % n;
                area += coords[i].x * coords[j].y;
                area -= coords[j].x * coords[i].y;
            }
            return Math.abs(area) / 2;
        }

        function validatePolygonClosure(sides) {
            const numSides = sides.length;
            const totalLength = sides.reduce((sum, length) => sum + length, 0);
            const maxSide = Math.max(...sides);
            if (sides.some(side => side < 0.01 || side > 1000000)) return false;
            if (maxSide >= (totalLength - maxSide)) return false;
            for (let i = 0; i < numSides; i++) {
                const side = sides[i];
                const otherSidesSum = totalLength - side;
                if (side >= otherSidesSum) return false;
            }
            return true;
        }

        function calculateAndDraw() {
            const numSides = parseInt(document.getElementById('numSides').value);
            const unit = document.getElementById('unit').value;
            const errorDiv = document.getElementById('errorMessage');

            errorDiv.innerHTML = '';
            state.sideLengths = [];
            for (let i = 1; i <= numSides; i++) {
                const length = parseFloat(document.getElementById(`side${i}`).value);
                if (isNaN(length) || length <= 0) {
                    showError('Please fill in all side lengths with positive numbers.');
                    return;
                }
                state.sideLengths.push(length);
            }

            if (state.sideLengths.length < 3) {
                showError('At least 3 sides are required.');
                return;
            }

            if (!validatePolygonClosure(state.sideLengths)) {
                showError('These side lengths cannot form a closed polygon.');
                return;
            }

            state.coordinates = constructPolygonFromSides(state.sideLengths);
            if (state.coordinates.length < 3) {
                showError('Could not construct a valid polygon.');
                return;
            }

            const areaInUnits = calculateArea(state.coordinates);
            const unitFactor = unitFactors[unit];
            const areaInSquareMeters = areaInUnits * unitFactor * unitFactor;

            if (areaInUnits < 0.0001) {
                showError('The calculated area is very small.');
            }

            state.lastCalculatedResults = { areaInUnits, unit, areaInSquareMeters };
            state.divisions = [];
            state.divisionAreas = [];
            document.getElementById('divisionSection').style.display = 'block';
            generateDivisionInputs();
            drawPlot();
            displayResults(areaInUnits, unit, areaInSquareMeters);
            saveToHistory();
            saveState();
            navigateTo('results');
        }

        // Plot Division
        function dividePlot() {
            const numParts = parseInt(document.getElementById('numParts').value);
            const divisionType = document.getElementById('divisionType').value;
            const divisionDirection = document.getElementById('divisionDirection').value;
            const errorDiv = document.getElementById('divisionError');
            errorDiv.innerHTML = '';

            if (!state.lastCalculatedResults) {
                showError('Please calculate the plot area first.', 'divisionError');
                return;
            }

            if (numParts < 2 || numParts > 10 || isNaN(numParts)) {
                showError('Please enter a number between 2 and 10 parts.', 'divisionError');
                return;
            }

            state.divisionAreas = [];
            let total = 0;
            if (divisionType === 'percentage') {
                for (let i = 1; i <= numParts; i++) {
                    const percentage = parseFloat(document.getElementById(`part${i}`).value);
                    if (isNaN(percentage) || percentage <= 0) {
                        showError('Please fill in all percentages with positive numbers.', 'divisionError');
                        return;
                    }
                    state.divisionAreas.push(percentage / 100 * state.lastCalculatedResults.areaInUnits);
                    total += percentage;
                }
                if (Math.abs(total - 100) > 0.01) {
                    showError('Percentages must sum to 100%.', 'divisionError');
                    return;
                }
            } else if (divisionType === 'area') {
                for (let i = 1; i <= numParts; i++) {
                    const area = parseFloat(document.getElementById(`part${i}`).value);
                    if (isNaN(area) || area <= 0) {
                        showError('Please fill in all areas with positive numbers.', 'divisionError');
                        return;
                    }
                    state.divisionAreas.push(area);
                    total += area;
                }
                if (Math.abs(total - state.lastCalculatedResults.areaInUnits) > 0.01) {
                    showError('Areas must sum to the total plot area.', 'divisionError');
                    return;
                }
            } else {
                state.divisionAreas = new Array(numParts).fill(state.lastCalculatedResults.areaInUnits / numParts);
            }

            state.divisions = calculateDivisions(state.divisionAreas, divisionDirection);
            drawPlot();
            displayResults(state.lastCalculatedResults.areaInUnits, state.lastCalculatedResults.unit, state.lastCalculatedResults.areaInSquareMeters);
            saveToHistory();
            saveState();
        }

        function calculateDivisions(areas, direction) {
            const divisions = [];
            let accumulatedArea = 0;
            const totalArea = state.lastCalculatedResults.areaInUnits;
            const minX = Math.min(...state.coordinates.map(c => c.x));
            const maxX = Math.max(...state.coordinates.map(c => c.x));
            const minY = Math.min(...state.coordinates.map(c => c.y));
            const maxY = Math.max(...state.coordinates.map(c => c.y));

            if (direction === 'horizontal') {
                const height = maxY - minY;
                const areaPerUnitHeight = totalArea / height;
                let currentY = minY;
                for (let i = 0; i < areas.length - 1; i++) {
                    accumulatedArea += areas[i];
                    const targetArea = accumulatedArea;
                    const targetHeight = targetArea / areaPerUnitHeight;
                    currentY = minY + targetHeight;
                    const intersections = findIntersectionsWithY(currentY);
                    if (intersections.length >= 2) {
                        intersections.sort((a, b) => a.x - b.x);
                        divisions.push({
                            start: intersections[0],
                            end: intersections[intersections.length - 1]
                        });
                    }
                }
            } else {
                const width = maxX - minX;
                const areaPerUnitWidth = totalArea / width;
                let currentX = minX;
                for (let i = 0; i < areas.length - 1; i++) {
                    accumulatedArea += areas[i];
                    const targetArea = accumulatedArea;
                    const targetWidth = targetArea / areaPerUnitWidth;
                    currentX = minX + targetWidth;
                    const intersections = findIntersectionsWithX(currentX);
                    if (intersections.length >= 2) {
                        intersections.sort((a, b) => a.y - b.y);
                        divisions.push({
                            start: intersections[0],
                            end: intersections[intersections.length - 1]
                        });
                    }
                }
            }
            return divisions;
        }

        function findIntersectionsWithY(y) {
            const intersections = [];
            for (let i = 0; i < state.coordinates.length; i++) {
                const p1 = state.coordinates[i];
                const p2 = state.coordinates[(i + 1) % state.coordinates.length];
                const minY = Math.min(p1.y, p2.y);
                const maxY = Math.max(p1.y, p2.y);
                if (y > minY && y <= maxY) {
                    const x = p1.x + (y - p1.y) * (p2.x - p1.x) / (p2.y - p1.y);
                    intersections.push({ x, y });
                }
            }
            return intersections;
        }

        function findIntersectionsWithX(x) {
            const intersections = [];
            for (let i = 0; i < state.coordinates.length; i++) {
                const p1 = state.coordinates[i];
                const p2 = state.coordinates[(i + 1) % state.coordinates.length];
                const minX = Math.min(p1.x, p2.x);
                const maxX = Math.max(p1.x, p2.x);
                if (x > minX && x <= maxX) {
                    const y = p1.y + (x - p1.x) * (p2.y - p1.y) / (p2.x - p1.x);
                    intersections.push({ x, y });
                }
            }
            return intersections;
        }

        // Canvas Rendering
        function drawPlot() {
            if (!state.ctx) return;
            clearCanvas(false);
            if (state.coordinates.length < 3) return;

            const minX = Math.min(...state.coordinates.map(c => c.x));
            const maxX = Math.max(...state.coordinates.map(c => c.x));
            const minY = Math.min(...state.coordinates.map(c => c.y));
            const maxY = Math.max(...state.coordinates.map(c => c.y));
            const width = maxX - minX || 1;
            const height = maxY - minY || 1;
            const padding = 20;
            const scaleX = (state.canvas.width - 2 * padding) / width;
            const scaleY = (state.canvas.height - 2 * padding) / height;
            state.scale = Math.min(scaleX, scaleY, 50) * state.zoomLevel;
            state.offsetX = (state.canvas.width - width * state.scale) / 2 - minX * state.scale + state.panX;
            state.offsetY = (state.canvas.height - height * state.scale) / 2 - minY * state.scale + state.panY;

            drawGrid();
            state.ctx.beginPath();
            state.ctx.strokeStyle = var(--primary-color);
            state.ctx.fillStyle = 'rgba(59, 130, 246, 0.2)';
            state.ctx.lineWidth = 3;
            state.coordinates.forEach((coord, index) => {
                const x = coord.x * state.scale + state.offsetX;
                const y = state.canvas.height - (coord.y * state.scale + state.offsetY);
                if (index === 0) state.ctx.moveTo(x, y);
                else state.ctx.lineTo(x, y);
            });
            state.ctx.closePath();
            state.ctx.fill();
            state.ctx.stroke();

            state.coordinates.forEach((coord, index) => {
                const x = coord.x * state.scale + state.offsetX;
                const y = state.canvas.height - (coord.y * state.scale + state.offsetY);
                state.ctx.beginPath();
                state.ctx.arc(x, y, 4, 0, 2 * Math.PI);
                state.ctx.fillStyle = '#ef4444';
                state.ctx.fill();
                state.ctx.fillStyle = var(--secondary-color);
                state.ctx.font = 'bold 12px Inter';
                state.ctx.fillText(`P${index + 1}`, x + 8, y - 8);
            });

            for (let i = 0; i < state.coordinates.length; i++) {
                const current = state.coordinates[i];
                const next = state.coordinates[(i + 1) % state.coordinates.length];
                const sideLength = state.sideLengths[i];
                const x1 = current.x * state.scale + state.offsetX;
                const y1 = state.canvas.height - (current.y * state.scale + state.offsetY);
                const x2 = next.x * state.scale + state.offsetX;
                const y2 = state.canvas.height - (next.y * state.scale + state.offsetY);
                const midX = (x1 + x2) / 2;
                const midY = (y1 + y2) / 2;
                const rectWidth = Math.max(30, 30 * state.scale / 50);
                const rectHeight = Math.max(20, 20 * state.scale / 50);

                state.ctx.fillStyle = i === state.selectedSideIndex ? 'rgba(255, 255, 0, 0.5)' : 'rgba(255, 255, 255, 0.9)';
                state.ctx.fillRect(midX - rectWidth / 2, midY - rectHeight / 2, rectWidth, rectHeight);
                state.ctx.fillStyle = var(--success-color);
                state.ctx.font = 'bold 12px Inter';
                state.ctx.textAlign = 'center';
                state.ctx.fillText(`S${i + 1}: ${sideLength.toFixed(2)}`, midX, midY + 4);
                state.ctx.textAlign = 'left';
            }

            if (state.divisions.length > 0) {
                state.divisions.forEach((division, index) => {
                    state.ctx.beginPath();
                    state.ctx.strokeStyle = '#ef4444';
                    state.ctx.lineWidth = 2;
                    state.ctx.setLineDash([5, 5]);
                    const x1 = division.start.x * state.scale + state.offsetX;
                    const y1 = state.canvas.height - (division.start.y * state.scale + state.offsetY);
                    const x2 = division.end.x * state.scale + state.offsetX;
                    const y2 = state.canvas.height - (division.end.y * state.scale + state.offsetY);
                    state.ctx.moveTo(x1, y1);
                    state.ctx.lineTo(x2, y2);
                    state.ctx.stroke();
                    state.ctx.setLineDash([]);

                    const midX = (x1 + x2) / 2;
                    const midY = (y1 + y2) / 2;
                    state.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    state.ctx.fillRect(midX - 20, midY - 10, 40, 20);
                    state.ctx.fillStyle = '#ef4444';
                    state.ctx.font = 'bold 12px Inter';
                    state.ctx.textAlign = 'center';
                    state.ctx.fillText(`D${index + 1}`, midX, midY + 4);
                    state.ctx.textAlign = 'left';
                });
            }
        }

        function drawGrid() {
            if (!state.ctx) return;
            state.ctx.strokeStyle = '#d1d5db';
            state.ctx.lineWidth = 1;
            const gridSpacing = Math.max(10, 20 / state.scale);
            for (let x = 0; x <= state.canvas.width; x += gridSpacing * state.scale) {
                state.ctx.beginPath();
                state.ctx.moveTo(x, 0);
                state.ctx.lineTo(x, state.canvas.height);
                state.ctx.stroke();
            }
            for (let y = 0; y <= state.canvas.height; y += gridSpacing * state.scale) {
                state.ctx.beginPath();
                state.ctx.moveTo(0, y);
                state.ctx.lineTo(state.canvas.width, y);
                state.ctx.stroke();
            }
        }

        // Canvas Interactions
        function handleCanvasClick(event) {
            const rect = state.canvas.getBoundingClientRect();
            const x = (event.clientX - rect.left - state.panX) / state.zoomLevel;
            const y = (event.clientY - rect.top - state.panY) / state.zoomLevel;

            for (let i = 0; i < state.coordinates.length; i++) {
                const current = state.coordinates[i];
                const next = state.coordinates[(i + 1) % state.coordinates.length];
                const x1 = current.x * state.scale + state.offsetX;
                const y1 = state.canvas.height - (current.y * state.scale + state.offsetY);
                const x2 = next.x * state.scale + state.offsetX;
                const y2 = state.canvas.height - (next.y * state.scale + state.offsetY);
                const midX = (x1 + x2) / 2;
                const midY = (y1 + y2) / 2;
                const rectWidth = Math.max(30, 30 * state.scale / 50);
                const rectHeight = Math.max(20, 20 * state.scale / 50);

                if (x >= midX - rectWidth / 2 && x <= midX + rectWidth / 2 &&
                    y >= midY - rectHeight / 2 && y <= midY + rectHeight / 2) {
                    state.selectedSideIndex = i;
                    const newLength = prompt(`Enter length for Side ${i + 1} (S${i + 1}):`, state.sideLengths[i]);
                    if (newLength !== null) {
                        const parsedLength = parseFloat(newLength);
                        if (!isNaN(parsedLength) && parsedLength > 0) {
                            state.sideLengths[i] = parsedLength;
                            document.getElementById(`side${i + 1}`).value = parsedLength;
                            saveState();
                            updatePlot();
                        } else {
                            alert('Please enter a valid positive number.');
                        }
                    }
                    drawPlot();
                    break;
                }
            }
        }

        function rotatePlot() {
            if (state.coordinates.length < 3) {
                showError('No valid plot to rotate.');
                return;
            }
            state.sideLengths = [state.sideLengths[state.sideLengths.length - 1], ...state.sideLengths.slice(0, -1)];
            for (let i = 1; i <= state.sideLengths.length; i++) {
                document.getElementById(`side${i}`).value = state.sideLengths[i - 1];
            }
            state.coordinates = state.coordinates.map(coord => ({
                x: coord.y,
                y: -coord.x
            }));
            state.rotationCount = (state.rotationCount + 1) % 4;
            saveState();
            updatePlot();
        }

        function zoomIn() {
            state.zoomLevel *= 1.2;
            drawPlot();
        }

        function zoomOut() {
            state.zoomLevel = Math.max(0.5, state.zoomLevel / 1.2);
            drawPlot();
        }

        function startPan(event) {
            state.isPanning = true;
            state.startX = event.clientX;
            state.startY = event.clientY;
        }

        function pan(event) {
            if (state.isPanning) {
                const dx = event.clientX - state.startX;
                const dy = event.clientY - state.startY;
                state.panX += dx / state.zoomLevel;
                state.panY += dy / state.zoomLevel;
                state.startX = event.clientX;
                state.startY = event.clientY;
                drawPlot();
            }
        }

        function endPan() {
            state.isPanning = false;
        }

        // Plot Updates
        function debounceUpdatePlot() {
            clearTimeout(state.updateTimeout);
            state.updateTimeout = setTimeout(updatePlot, 300);
        }

        function debounceDividePlot() {
            clearTimeout(state.updateTimeout);
            state.updateTimeout = setTimeout(dividePlot, 300);
        }

        function updatePlot() {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.innerHTML = '';

            if (state.sideLengths.some(length => length <= 0 || isNaN(length))) {
                return;
            }

            if (!validatePolygonClosure(state.sideLengths)) {
                showError('These side lengths cannot form a closed polygon.');
                return;
            }

            state.coordinates = constructPolygonFromSides(state.sideLengths);
            if (state.coordinates.length < 3) {
                showError('Could not construct a valid polygon.');
                return;
            }

            const unit = document.getElementById('unit').value;
            const areaInUnits = calculateArea(state.coordinates);
            const unitFactor = unitFactors[unit];
            const areaInSquareMeters = areaInUnits * unitFactor * unitFactor;

            state.lastCalculatedResults = { areaInUnits, unit, areaInSquareMeters };
            state.divisions = [];
            state.divisionAreas = [];
            document.getElementById('divisionSection').style.display = 'block';
            generateDivisionInputs();
            drawPlot();
            displayResults(areaInUnits, unit, areaInSquareMeters);
            saveToHistory();
            saveState();
        }

        // Results and History
        function displayResults(areaInUnits, unit, areaInSquareMeters) {
            const resultsDiv = document.getElementById('resultsDisplay');
            let conversionsHTML = '';
            for (const [convertUnit, factor] of Object.entries(areaConversions)) {
                const convertedArea = areaInSquareMeters * factor;
                conversionsHTML += `
                    <div class="unit-conversion">
                        <strong>${convertedArea.toFixed(4)}</strong> ${convertUnit}
                    </div>
                `;
            }

            const totalPerimeter = state.sideLengths.reduce((sum, length) => sum + length, 0);
            let divisionHTML = '';
            if (state.divisions.length > 0) {
                const divisionType = document.getElementById('divisionType').value;
                const divisionDirection = document.getElementById('divisionDirection').value;
                divisionHTML = `<h3>Divided Areas (${divisionDirection})</h3>`;
                state.divisionAreas.forEach((area, index) => {
                    let label = `Part ${index + 1}: ${area.toFixed(4)} sq ${unit}`;
                    if (divisionType === 'percentage') {
                        const percentage = (area / areaInUnits * 100).toFixed(2);
                        label += ` (${percentage}%)`;
                    }
                    divisionHTML += `<p><strong>${label}</strong></p>`;
                });
            }

            resultsDiv.innerHTML = `
                <div class="results">
                    <h3>Calculated Areas</h3>
                    <p><strong>Area:</strong> ${areaInUnits.toFixed(4)} sq ${unit}</p>
                    <p><strong>Perimeter:</strong> ${totalPerimeter.toFixed(2)} ${unit}</p>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 8px;">
                        ${conversionsHTML}
                    </div>
                    ${divisionHTML}
                </div>
            `;
        }

        function saveToHistory() {
            const historyEntry = {
                timestamp: new Date().toISOString(),
                sideLengths: [...state.sideLengths],
                unit: document.getElementById('unit').value,
                areaInUnits: state.lastCalculatedResults?.areaInUnits,
                areaInSquareMeters: state.lastCalculatedResults?.areaInSquareMeters,
                divisions: [...state.divisions],
                divisionAreas: [...state.divisionAreas],
                divisionType: document.getElementById('divisionType').value,
                divisionDirection: document.getElementById('divisionDirection').value
            };
            state.history.unshift(historyEntry);
            if (state.history.length > 50) state.history.pop();
            localStorage.setItem('plotHistory', JSON.stringify(state.history));
            displayHistory();
        }

        function displayHistory() {
            const historyList = document.getElementById('historyList');
            historyList.innerHTML = '';
            state.history.forEach((entry, index) => {
                const item = document.createElement('div');
                item.className = 'history-item';
                item.innerHTML = `
                    <p><strong>Calculation ${index + 1}</strong> - ${new Date(entry.timestamp).toLocaleString()}</p>
                    <p>Area: ${entry.areaInUnits?.toFixed(4)} sq ${entry.unit}</p>
                    <p>Sides: ${entry.sideLengths.join(', ')}</p>
                `;
                item.onclick = () => loadHistoryEntry(index);
                historyList.appendChild(item);
            });
        }

        function loadHistoryEntry(index) {
            const entry = state.history[index];
            document.getElementById('numSides').value = entry.sideLengths.length;
            document.getElementById('unit').value = entry.unit;
            state.sideLengths = entry.sideLengths;
            generateSideInputs();
            for (let i = 1; i <= state.sideLengths.length; i++) {
                document.getElementById(`side${i}`).value = state.sideLengths[i-1];
            }
            calculateAndDraw();
            if (entry.divisions.length > 0) {
                document.getElementById('numParts').value = entry.divisionAreas.length;
                document.getElementById('divisionType').value = entry.divisionType;
                document.getElementById('divisionDirection').value = entry.divisionDirection;
                state.divisionAreas = entry.divisionAreas;
                generateDivisionInputs();
                for (let i = 1; i <= state.divisionAreas.length; i++) {
                    document.getElementById(`part${i}`).value = state.divisionAreas[i-1];
                }
                state.divisions = entry.divisions;
                drawPlot();
                displayResults(entry.areaInUnits, entry.unit, entry.areaInSquareMeters);
            }
            navigateTo('editor');
        }

        function clearHistory() {
            state.history = [];
            localStorage.setItem('plotHistory', JSON.stringify(state.history));
            displayHistory();
        }

        // Canvas Utilities
        function clearCanvas(hideResults = true) {
            if (!state.ctx) return;
            state.ctx.clearRect(0, 0, state.canvas.width, state.canvas.height);
            state.ctx.fillStyle = var(--white);
            state.ctx.fillRect(0, 0, state.canvas.width, state.canvas.height);
            if (hideResults) {
                document.getElementById('resultsDisplay').innerHTML = '';
                document.getElementById('divisionSection').style.display = 'none';
                state.lastCalculatedResults = null;
                state.sideLengths = [];
                state.coordinates = [];
                state.divisions = [];
                state.divisionAreas = [];
                state.selectedSideIndex = -1;
                state.rotationCount = 0;
                state.zoomLevel = 1;
                state.panX = 0;
                state.panY = 0;
            }
            saveState();
        }

        function downloadCanvas() {
            if (!state.ctx) return;
            state.ctx.save();
            state.ctx.font = '10px Inter';
            state.ctx.fillStyle = var(--secondary-color);
            state.ctx.textAlign = 'right';
            state.ctx.fillText('Generated by PlotMaster | unifyxproject.netlify.app', state.canvas.width - 10, state.canvas.height - 10);

            const link = document.createElement('a');
            link.download = 'plot-master.png';
            link.href = state.canvas.toDataURL('image/png', 1.0);
            link.click();

            state.ctx.restore();
            drawPlot();
        }

        function downloadResultsAsPDF() {
            if (!window.jspdf) {
                showError('PDF library not loaded.');
                return;
            }
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({
                orientation: 'portrait',
                unit: 'mm',
                format: 'a4'
            });

            doc.setFillColor(59, 130, 246);
            doc.rect(0, 0, 210, 30, 'F');
            doc.setFontSize(16);
            doc.setTextColor(255, 255, 255);
            doc.setFont('helvetica', 'bold');
            doc.text('PlotMaster Area Report', 10, 15);
            doc.setFontSize(10);
            doc.text(`Generated: ${new Date().toLocaleString()}`, 10, 25);

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = state.canvas.width * 2;
            tempCanvas.height = state.canvas.height * 2;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.scale(2, 2);
            tempCtx.translate(state.canvas.width / 2 + state.panX, state.canvas.height / 2 + state.panY);
            tempCtx.rotate(state.rotationCount * Math.PI / 2);
            tempCtx.translate(-state.canvas.width / 2, -state.canvas.height / 2);
            tempCtx.fillStyle = var(--white);
            tempCtx.fillRect(0, 0, state.canvas.width, state.canvas.height);
            drawGridOnCanvas(tempCtx);

            tempCtx.beginPath();
            tempCtx.strokeStyle = var(--primary-color);
            tempCtx.fillStyle = 'rgba(59, 130, 246, 0.2)';
            tempCtx.lineWidth = 3;
            state.coordinates.forEach((coord, index) => {
                const x = coord.x * state.scale + state.offsetX;
                const y = state.canvas.height - (coord.y * state.scale + state.offsetY);
                if (index === 0) tempCtx.moveTo(x, y);
                else tempCtx.lineTo(x, y);
            });
            tempCtx.closePath();
            tempCtx.fill();
            tempCtx.stroke();

            state.coordinates.forEach((coord, index) => {
                const x = coord.x * state.scale + state.offsetX;
                const y = state.canvas.height - (coord.y * state.scale + state.offsetY);
                tempCtx.beginPath();
                tempCtx.arc(x, y, 4, 0, 2 * Math.PI);
                tempCtx.fillStyle = '#ef4444';
                tempCtx.fill();
                tempCtx.fillStyle = var(--secondary-color);
                tempCtx.font = 'bold 12px Inter';
                tempCtx.fillText(`P${index + 1}`, x + 8, y - 8);
            });

            for (let i = 0; i < state.coordinates.length; i++) {
                const current = state.coordinates[i];
                const next = state.coordinates[(i + 1) % state.coordinates.length];
                const sideLength = state.sideLengths[i];
                const x1 = current.x * state.scale + state.offsetX;
                const y1 = state.canvas.height - (current.y * state.scale + state.offsetY);
                const x2 = next.x * state.scale + state.offsetX;
                const y2 = state.canvas.height - (next.y * state.scale + state.offsetY);
                const midX = (x1 + x2) / 2;
                const midY = (y1 + y2) / 2;
                const rectWidth = Math.max(30, 30 * state.scale / 50);
                const rectHeight = Math.max(20, 20 * state.scale / 50);
                tempCtx.fillStyle = i === state.selectedSideIndex ? 'rgba(255, 255, 0, 0.5)' : 'rgba(255, 255, 255, 0.9)';
                tempCtx.fillRect(midX - rectWidth / 2, midY - rectHeight / 2, rectWidth, rectHeight);
                tempCtx.fillStyle = var(--success-color);
                tempCtx.font = 'bold 12px Inter';
                tempCtx.textAlign = 'center';
                tempCtx.fillText(`S${i + 1}: ${sideLength.toFixed(2)}`, midX, midY + 4);
                tempCtx.textAlign = 'left';
            }

            if (state.divisions.length > 0) {
                state.divisions.forEach((division, index) => {
                    tempCtx.beginPath();
                    tempCtx.strokeStyle = '#ef4444';
                    tempCtx.lineWidth = 2;
                    tempCtx.setLineDash([5, 5]);
                    const x1 = division.start.x * state.scale + state.offsetX;
                    const y1 = state.canvas.height - (division.start.y * state.scale + state.offsetY);
                    const x2 = division.end.x * state.scale + state.offsetX;
                    const y2 = state.canvas.height - (division.end.y * state.scale + state.offsetY);
                    tempCtx.moveTo(x1, y1);
                    tempCtx.lineTo(x2, y2);
                    tempCtx.stroke();
                    tempCtx.setLineDash([]);
                    const midX = (x1 + x2) / 2;
                    const midY = (y1 + y2) / 2;
                    tempCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    tempCtx.fillRect(midX - 20, midY - 10, 40, 20);
                    tempCtx.fillStyle = '#ef4444';
                    tempCtx.font = 'bold 12px Inter';
                    tempCtx.textAlign = 'center';
                    tempCtx.fillText(`D${index + 1}`, midX, midY + 4);
                    tempCtx.textAlign = 'left';
                });
            }

            tempCtx.font = '10px Inter';
            tempCtx.fillStyle = var(--secondary-color);
            tempCtx.textAlign = 'right';
            tempCtx.fillText('Generated by PlotMaster | unifyxproject.netlify.app', state.canvas.width - 10, state.canvas.height - 10);
            const imgData = tempCanvas.toDataURL('image/png', 1.0);
            doc.addImage(imgData, 'PNG', 10, 35, 190, 152);

            if (state.lastCalculatedResults) {
                const { areaInUnits, unit, areaInSquareMeters } = state.lastCalculatedResults;
                const totalPerimeter = state.sideLengths.reduce((sum, length) => sum + length, 0);

                doc.setFillColor(243, 244, 246);
                doc.rect(10, 195, 190, state.divisions.length > 0 ? 100 : 85, 'F');
                doc.setDrawColor(59, 130, 246);
                doc.setLineWidth(0.5);
                doc.rect(10, 195, 190, state.divisions.length > 0 ? 100 : 85);

                doc.setFontSize(14);
                doc.setTextColor(31, 41, 55);
                doc.setFont('helvetica', 'bold');
                doc.text('Calculated Results', 15, 205);
                doc.setFontSize(12);
                doc.setTextColor(0, 0, 0);
                doc.text(`Area: ${areaInUnits.toFixed(4)} square ${unit}`, 15, 215);
                doc.text(`Perimeter: ${totalPerimeter.toFixed(2)} ${unit}`, 15, 225);

                let yOffset = 235;
                doc.setFontSize(10);
                for (const [convertUnit, factor] of Object.entries(areaConversions)) {
                    if (yOffset >= 270) break;
                    const convertedArea = areaInSquareMeters * factor;
                    doc.setFillColor(255, 255, 255);
                    doc.roundedRect(15, yOffset - 4, 80, 10, 2, 2, 'F');
                    doc.setTextColor(0, 0, 0);
                    doc.text(`${convertedArea.toFixed(4)} ${convertUnit}`, 20, yOffset + 4);
                    yOffset += 12;
                }

                if (state.divisions.length > 0) {
                    doc.setFontSize(12);
                    doc.setTextColor(31, 41, 55);
                    const divisionDirection = document.getElementById('divisionDirection').value;
                    doc.text(`Divided Areas (${divisionDirection})`, 15, yOffset);
                    yOffset += 10;
                    doc.setFontSize(10);
                    const divisionType = document.getElementById('divisionType').value;
                    state.divisionAreas.forEach((area, index) => {
                        let label = `Part ${index + 1}: ${area.toFixed(4)} sq ${unit}`;
                        if (divisionType === 'percentage') {
                            const percentage = (area / areaInUnits * 100).toFixed(2);
                            label += ` (${percentage}%)`;
                        }
                        doc.text(label, 20, yOffset + 4);
                        yOffset += 10;
                    });
                }
            } else {
                doc.setFontSize(12);
                doc.setTextColor(239, 68, 68);
                doc.text('No results available.', 10, 195);
            }

            doc.setFontSize(8);
            doc.setTextColor(31, 41, 55);
            doc.setFont('helvetica', 'normal');
            doc.text('Generated by PlotMaster | unifyxproject.netlify.app', 10, 290);
            doc.save('plot-master-report.pdf');
        }

        function drawGridOnCanvas(context) {
            context.strokeStyle = '#d1d5db';
            context.lineWidth = 1;
            const gridSpacing = Math.max(10, 20 / state.scale);
            for (let x = 0; x <= state.canvas.width; x += gridSpacing * state.scale) {
                context.beginPath();
                context.moveTo(x, 0);
                context.lineTo(x, state.canvas.height);
                context.stroke();
            }
            for (let y = 0; y <= state.canvas.height; y += gridSpacing * state.scale) {
                context.beginPath();
                context.moveTo(0, y);
                context.lineTo(state.canvas.width, y);
                context.stroke();
            }
        }

        // Utility
        function showError(message, target = 'errorMessage') {
            document.getElementById(target).innerHTML = `<div class="error">${message}</div>`;
        }

        // Initialization
        window.onload = function() {
            initCanvas();
            loadState();
            displayHistory();
            document.querySelectorAll('.nav-item').forEach(item => {
                if (item.dataset.page) {
                    item.addEventListener('click', () => navigateTo(item.dataset.page));
                }
            });
            document.getElementById('divisionType').addEventListener('change', generateDivisionInputs);
            document.getElementById('numSides').addEventListener('input', generateSideInputs);
            window.addEventListener('resize', () => {
                initCanvas();
                if (state.coordinates.length > 0) drawPlot();
            });
        };
    </script>
</body>
</html>